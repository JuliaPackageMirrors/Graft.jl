{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\n\n\nThe Graph Type\n\n\nThe Graph datatype is the core data-structure used in Graft.jl. The Graph datatype has the following fields:\n\n\n\n\nnv\n     : The number of vertices in the graph.\n\n\nne\n     : The number of edges int he graph.\n\n\nindxs\n  : The adjacency matrix for the graph. The SparseMatrixCSC type is used here, both            as an adjacency matrix and as an index table, that maps edges onto their entries in the            edge dataframe.\n\n\nvdata\n  : A dataframe used to store vertex data. This dataframe is indexed by the internally used            vertex identifiers.\n\n\nedata\n  : An edge dataframe used to store edge data. This dataframe is indexed by indxs datastructure.\n\n\nlmap\n   : A label map that maps externally used labels onto the internally used vertex identifiers and vice versa.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/#the-graph-type", 
            "text": "The Graph datatype is the core data-structure used in Graft.jl. The Graph datatype has the following fields:   nv      : The number of vertices in the graph.  ne      : The number of edges int he graph.  indxs   : The adjacency matrix for the graph. The SparseMatrixCSC type is used here, both            as an adjacency matrix and as an index table, that maps edges onto their entries in the            edge dataframe.  vdata   : A dataframe used to store vertex data. This dataframe is indexed by the internally used            vertex identifiers.  edata   : An edge dataframe used to store edge data. This dataframe is indexed by indxs datastructure.  lmap    : A label map that maps externally used labels onto the internally used vertex identifiers and vice versa.", 
            "title": "The Graph Type"
        }, 
        {
            "location": "/generator/", 
            "text": "Graph Generation\n\n\nThe \nGraph\n constructor can be used directly to generate random regular graphs:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \n# Generate a graph with 10 vertices and no edges.\n\n       \nGraph\n(\n10\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n0\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Generate a graph with 10 vertices and (approximately) 50 edges\n\n       \nGraph\n(\n10\n,\n \n50\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n51\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Generate a labelled graph with 10 vertices\n\n       \n# labelled \n1\n through \n10\n and no edges\n\n       \nGraph\n(\n10\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n))\n\n\nGraph\n(\n10\n \nvertices\n,\n \n0\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Generate a labelled graph with 10 vertices\n\n       \n# and (approximately) 50 edges\n\n       \nGraph\n(\n10\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n),\n \n50\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n51\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Generate graph from an adjacency matrix (may cause self loops)\n\n       \nGraph\n(\nsprand\n(\nInt\n,\n \n10\n,\n \n10\n,\n \n.\n3\n))\n\n\nGraph\n(\n10\n \nvertices\n,\n \n25\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\n\n\n\ncompletegraph\n can be used to generate a complete graph\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \n# Generate a complete graph with 10 vertices\n\n       \ng\n \n=\n \ncompletegraph\n(\n10\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n90\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\n\n\n\nrandgraph\n can be used to generate a complete graph, with floating point vertex and edge properties:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \n# Generate a graph with 10 vertices, 90 edges, 2 vertex properties and 2 edge properties\n\n       \ng\n \n=\n \npropgraph\n(\n10\n,\n \n[:\np1\n,:\np2\n],\n \n[:\np1\n,:\np2\n])\n\n\nGraph\n(\n10\n \nvertices\n,\n \n90\n \nedges\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nedge\n \nproperties\n)\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.Graph\n \n \nMethod\n.\n\n\nBuild an empty graph with nv vertices \n\n\nsource\n\n\n#\n\n\nGraft.Graph\n \n \nMethod\n.\n\n\nBuild a graph with nv vertices and (approximately)ne edges \n\n\nsource\n\n\n#\n\n\nGraft.Graph\n \n \nMethod\n.\n\n\nBuild an empty graph with nv labelled vertices \n\n\nsource\n\n\n#\n\n\nGraft.Graph\n \n \nMethod\n.\n\n\nBuild a graph with nv labelled vertices and (approximately)ne edges \n\n\nsource\n\n\n#\n\n\nGraft.Graph\n \n \nMethod\n.\n\n\nBuild a graph using the input adjacency matrix \n\n\nsource\n\n\n#\n\n\nGraft.completegraph\n \n \nFunction\n.\n\n\nBuild a complete graph with nv vertices \n\n\nsource\n\n\n#\n\n\nGraft.randgraph\n \n \nFunction\n.\n\n\nBuild a graph with nv vertices and (approximately)ne edges \n\n\nsource\n\n\nBuild a graph with nv vertices and a random number of edges \n\n\nsource\n\n\n#\n\n\nGraft.propgraph\n \n \nFunction\n.\n\n\nReturns a small completegraph with properties(for doc examples) \n\n\nsource", 
            "title": "Generation"
        }, 
        {
            "location": "/generator/#graph-generation", 
            "text": "The  Graph  constructor can be used directly to generate random regular graphs:  julia   using   Graft  julia   # Generate a graph with 10 vertices and no edges. \n        Graph ( 10 )  Graph ( 10   vertices ,   0   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Generate a graph with 10 vertices and (approximately) 50 edges \n        Graph ( 10 ,   50 )  Graph ( 10   vertices ,   51   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Generate a labelled graph with 10 vertices \n        # labelled  1  through  10  and no edges \n        Graph ( 10 ,   map ( string ,   1   :   10 ))  Graph ( 10   vertices ,   0   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Generate a labelled graph with 10 vertices \n        # and (approximately) 50 edges \n        Graph ( 10 ,   map ( string ,   1   :   10 ),   50 )  Graph ( 10   vertices ,   51   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Generate graph from an adjacency matrix (may cause self loops) \n        Graph ( sprand ( Int ,   10 ,   10 ,   . 3 ))  Graph ( 10   vertices ,   25   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )   completegraph  can be used to generate a complete graph  julia   using   Graft  julia   # Generate a complete graph with 10 vertices \n        g   =   completegraph ( 10 )  Graph ( 10   vertices ,   90   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )   randgraph  can be used to generate a complete graph, with floating point vertex and edge properties:  julia   using   Graft  julia   # Generate a graph with 10 vertices, 90 edges, 2 vertex properties and 2 edge properties \n        g   =   propgraph ( 10 ,   [: p1 ,: p2 ],   [: p1 ,: p2 ])  Graph ( 10   vertices ,   90   edges ,   Symbol [: p1 ,: p2 ]   vertex   properties ,   Symbol [: p1 ,: p2 ]   edge   properties )   Detailed documentation:  #  Graft.Graph     Method .  Build an empty graph with nv vertices   source  #  Graft.Graph     Method .  Build a graph with nv vertices and (approximately)ne edges   source  #  Graft.Graph     Method .  Build an empty graph with nv labelled vertices   source  #  Graft.Graph     Method .  Build a graph with nv labelled vertices and (approximately)ne edges   source  #  Graft.Graph     Method .  Build a graph using the input adjacency matrix   source  #  Graft.completegraph     Function .  Build a complete graph with nv vertices   source  #  Graft.randgraph     Function .  Build a graph with nv vertices and (approximately)ne edges   source  Build a graph with nv vertices and a random number of edges   source  #  Graft.propgraph     Function .  Returns a small completegraph with properties(for doc examples)   source", 
            "title": "Graph Generation"
        }, 
        {
            "location": "/combinatorial/", 
            "text": "Combinatorial API\n\n\nThe following example demonstrates the use of the combinatorial API:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \ncompletegraph\n(\n10\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n90\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n))\n\n\n\njulia\n \n# The number of vertices in the graph\n\n       \nnv\n(\ng\n)\n\n\n10\n\n\n\njulia\n \n# The number of edges in the graph\n\n       \nne\n(\ng\n)\n\n\n90\n\n\n\njulia\n \n# The internally used vertex identifiers\n\n       \nvertices\n(\ng\n)\n\n\n1\n:\n10\n\n\n\njulia\n \n# Get an iterator overt all edges in the graph\n\n       \nedges\n(\ng\n)\n\n\n90\n-\nelement\n \nGraft\n.\nEdgeIter\n:\n\n \n1\n=\n2\n\n \n1\n=\n3\n\n \n1\n=\n4\n\n \n1\n=\n5\n\n \n1\n=\n6\n\n \n1\n=\n7\n\n \n1\n=\n8\n\n \n1\n=\n9\n\n \n1\n=\n10\n\n \n2\n=\n1\n\n \n\u22ee\n\n \n10\n=\n1\n\n \n10\n=\n2\n\n \n10\n=\n3\n\n \n10\n=\n4\n\n \n10\n=\n5\n\n \n10\n=\n6\n\n \n10\n=\n7\n\n \n10\n=\n8\n\n \n10\n=\n9\n\n\n\njulia\n \n# Check if the input vertex identifier exists in the graph\n\n       \nhasvertex\n(\ng\n,\n \n11\n)\n\n\nfalse\n\n\n\njulia\n \n# Check if the input edge exists in the graph\n\n       \nhasedge\n(\ng\n,\n \n1\n=\n1\n)\n\n\nfalse\n\n\n\njulia\n \n# Get a list containing the input vertex\ns out-neighbors\n\n       \nfadj\n(\ng\n,\n \n1\n)\n\n\n9\n-\nelement\n \nArray\n{\nInt64\n,\n1\n}:\n\n  \n2\n\n  \n3\n\n  \n4\n\n  \n5\n\n  \n6\n\n  \n7\n\n  \n8\n\n  \n9\n\n \n10\n\n\n\njulia\n \n# Get the out-neighbors of a labelled vertex\n\n       \ng\n[\n1\n]\n\n\n9\n-\nelement\n \nArray\n{\nString\n,\n1\n}:\n\n \n2\n\n \n3\n\n \n4\n\n \n5\n\n \n6\n\n \n7\n\n \n8\n\n \n9\n\n \n10\n\n\n\njulia\n \n# Get the input vertex\ns out-neighbors in a preallocated array\n\n       \nadj\n \n=\n \nsizehint!\n(\nInt\n[],\n \nnv\n(\ng\n));\n\n\n\njulia\n \nfadj!\n(\ng\n,\n \n1\n,\n \nadj\n)\n\n\n9\n-\nelement\n \nArray\n{\nInt64\n,\n1\n}:\n\n  \n2\n\n  \n3\n\n  \n4\n\n  \n5\n\n  \n6\n\n  \n7\n\n  \n8\n\n  \n9\n\n \n10\n\n\n\njulia\n \n# Count the number of out-neighbors the input vertex has\n\n       \noutdegree\n(\ng\n,\n \n1\n)\n\n\n9\n\n\n\njulia\n \n# Count the number of in-neighbors the input vertex has\n\n       \nindegree\n(\ng\n,\n \n1\n)\n\n\n9\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.nv\n \n \nMethod\n.\n\n\nThe number of vertices in the graph \n\n\nsource\n\n\n#\n\n\nGraft.ne\n \n \nMethod\n.\n\n\nThe number of edges in the graph \n\n\nsource\n\n\n#\n\n\nGraft.fadj\n \n \nMethod\n.\n\n\nVertex v's out-neighbors in the graph \n\n\nsource\n\n\n#\n\n\nGraft.fadj!\n \n \nMethod\n.\n\n\nRetrieve a list of vertices connect to vertex v.\n\n\nThis method copies the adjacencies onto the input array, and is comparitively faster, and causes no mallocs.\n\n\nsource\n\n\n#\n\n\nGraft.outdegree\n \n \nMethod\n.\n\n\nVertex v's outdegree in the graph \n\n\nsource\n\n\n#\n\n\nGraft.indegree\n \n \nMethod\n.\n\n\nVertex v's indegree in the graph \n\n\nsource", 
            "title": "Combinatorial"
        }, 
        {
            "location": "/combinatorial/#combinatorial-api", 
            "text": "The following example demonstrates the use of the combinatorial API:  julia   using   Graft  julia   g   =   completegraph ( 10 )  Graph ( 10   vertices ,   90   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   setlabel! ( g ,   map ( string ,   1   :   10 ))  julia   # The number of vertices in the graph \n        nv ( g )  10  julia   # The number of edges in the graph \n        ne ( g )  90  julia   # The internally used vertex identifiers \n        vertices ( g )  1 : 10  julia   # Get an iterator overt all edges in the graph \n        edges ( g )  90 - element   Graft . EdgeIter : \n  1 = 2 \n  1 = 3 \n  1 = 4 \n  1 = 5 \n  1 = 6 \n  1 = 7 \n  1 = 8 \n  1 = 9 \n  1 = 10 \n  2 = 1 \n  \u22ee \n  10 = 1 \n  10 = 2 \n  10 = 3 \n  10 = 4 \n  10 = 5 \n  10 = 6 \n  10 = 7 \n  10 = 8 \n  10 = 9  julia   # Check if the input vertex identifier exists in the graph \n        hasvertex ( g ,   11 )  false  julia   # Check if the input edge exists in the graph \n        hasedge ( g ,   1 = 1 )  false  julia   # Get a list containing the input vertex s out-neighbors \n        fadj ( g ,   1 )  9 - element   Array { Int64 , 1 }: \n   2 \n   3 \n   4 \n   5 \n   6 \n   7 \n   8 \n   9 \n  10  julia   # Get the out-neighbors of a labelled vertex \n        g [ 1 ]  9 - element   Array { String , 1 }: \n  2 \n  3 \n  4 \n  5 \n  6 \n  7 \n  8 \n  9 \n  10  julia   # Get the input vertex s out-neighbors in a preallocated array \n        adj   =   sizehint! ( Int [],   nv ( g ));  julia   fadj! ( g ,   1 ,   adj )  9 - element   Array { Int64 , 1 }: \n   2 \n   3 \n   4 \n   5 \n   6 \n   7 \n   8 \n   9 \n  10  julia   # Count the number of out-neighbors the input vertex has \n        outdegree ( g ,   1 )  9  julia   # Count the number of in-neighbors the input vertex has \n        indegree ( g ,   1 )  9   Detailed documentation:  #  Graft.nv     Method .  The number of vertices in the graph   source  #  Graft.ne     Method .  The number of edges in the graph   source  #  Graft.fadj     Method .  Vertex v's out-neighbors in the graph   source  #  Graft.fadj!     Method .  Retrieve a list of vertices connect to vertex v.  This method copies the adjacencies onto the input array, and is comparitively faster, and causes no mallocs.  source  #  Graft.outdegree     Method .  Vertex v's outdegree in the graph   source  #  Graft.indegree     Method .  Vertex v's indegree in the graph   source", 
            "title": "Combinatorial API"
        }, 
        {
            "location": "/mutation/", 
            "text": "Mutation API\n\n\nThe following example demonstrates the use of the combinatorial API:Graphs can be modified using the following methods:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \ncompletegraph\n(\n10\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n90\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n))\n\n\n\njulia\n \n# Add a labelled vertex to the graph. Returns the new\n\n       \n# vertex\ns internal identifier\n\n       \naddvertex!\n(\ng\n,\n \n11\n)\n\n\n11\n\n\n\njulia\n \n# Add a new edge to the graph, using vertex identifiers\n\n       \naddedge!\n(\ng\n,\n \n1\n=\n11\n)\n\n\ntrue\n\n\n\njulia\n \n# Add a new edge to the graph, using vertex labels\n\n       \ng\n[\n2\n]\n \n=\n \n11\n\n\n11\n\n\n\njulia\n \n# Remove an edge from the graph, using vertex identifiers\n\n       \nrmedge!\n(\ng\n,\n \n1\n=\n11\n)\n\n\n\njulia\n \n# Remove a vertex from the graph, using its vertex identifier\n\n       \nrmvertex!\n(\ng\n,\n \n1\n)\n\n\n\njulia\n \n# Remove a vertex from the graph using its label\n\n       \ng\n \n-\n \n5\n\n\n\n\n\n\nDetailed documentation:\n\n\naddvertex!(::Graph, ::Any)\naddvertex!(::Graph, ::Any)\naddedge!(::Graph, ::Pair{Int,Int})\nrmvertex!(::Graph, ::Int)\nrmvertex!(::Graph, ::AbstractVector{Int})\nrmedge!(::Graph, ::Pair{Int,Int})", 
            "title": "Mutation"
        }, 
        {
            "location": "/mutation/#mutation-api", 
            "text": "The following example demonstrates the use of the combinatorial API:Graphs can be modified using the following methods:  julia   using   Graft  julia   g   =   completegraph ( 10 )  Graph ( 10   vertices ,   90   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   setlabel! ( g ,   map ( string ,   1   :   10 ))  julia   # Add a labelled vertex to the graph. Returns the new \n        # vertex s internal identifier \n        addvertex! ( g ,   11 )  11  julia   # Add a new edge to the graph, using vertex identifiers \n        addedge! ( g ,   1 = 11 )  true  julia   # Add a new edge to the graph, using vertex labels \n        g [ 2 ]   =   11  11  julia   # Remove an edge from the graph, using vertex identifiers \n        rmedge! ( g ,   1 = 11 )  julia   # Remove a vertex from the graph, using its vertex identifier \n        rmvertex! ( g ,   1 )  julia   # Remove a vertex from the graph using its label \n        g   -   5   Detailed documentation:  addvertex!(::Graph, ::Any)\naddvertex!(::Graph, ::Any)\naddedge!(::Graph, ::Pair{Int,Int})\nrmvertex!(::Graph, ::Int)\nrmvertex!(::Graph, ::AbstractVector{Int})\nrmedge!(::Graph, ::Pair{Int,Int})", 
            "title": "Mutation API"
        }, 
        {
            "location": "/labelling/", 
            "text": "Labelling\n\n\nBy default, a vertex is identified by its internal identifier. However, a user can assign labels of any arbitrary Julia type to identify vertices. However, these labels can be used only externally. Internally, the vertices will still be identified by their integer ids. This is done has vertex label resolution can impose a significant overhead.\n\n\nThe following example demonstrates the Labelling API:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \ncompletegraph\n(\n10\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n90\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Set labels \n1\n, \n2\n ... \n10\n to the vertices\n\n       \nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n))\n\n\n\njulia\n \n# Translate labels into vertex identifiers\n\n       \ndecode\n(\ng\n,\n \n1\n)\n\n\n1\n\n\n\njulia\n \n# Decode a labelled edge\n\n       \ndecode\n(\ng\n,\n \n1\n=\n2\n)\n\n\n1\n=\n2\n\n\n\njulia\n \n# Translate vertex identifiers into labels\n\n       \nencode\n(\ng\n,\n \n1\n)\n\n\n1\n\n\n\njulia\n \n# Encode an edge\n\n       \nencode\n(\ng\n,\n \n1\n=\n2\n)\n\n\n1\n=\n2\n\n\n\njulia\n \n# Relabel a vertex\n\n       \nrelabel!\n(\ng\n,\n \n1\n,\n \nONE\n)\n\n\n\njulia\n \n# Remove all vertex labels (Use vertex identifiers instead)\n\n       \nsetlabel!\n(\ng\n)\n\n\n\njulia\n \n# Display all vertex labels (defaults to vertex identifiers in this case)\n\n       \nencode\n(\ng\n)\n\n\n10\n-\nelement\n \nArray\n{\nInt64\n,\n1\n}:\n\n  \n1\n\n  \n2\n\n  \n3\n\n  \n4\n\n  \n5\n\n  \n6\n\n  \n7\n\n  \n8\n\n  \n9\n\n \n10\n\n\n\n\n\n\nDetailed documentation:\n\n\nsetlabel!(::Graph, ::Vector)\nsetlabel!(::Graph)\ndecode(::Graph, ::Any)\ndecode(::Graph, ::Pair)\nencode(::Graph, ::Int)\nencode(::Graph, ::Pair{Int,Int})\nencode(::Graph)\nrelabel!(::Graph, ::Int, ::Any)\nrelabel!(::Graph, ::AbstractVector{Int}, ::Vector)", 
            "title": "Labelling"
        }, 
        {
            "location": "/labelling/#labelling", 
            "text": "By default, a vertex is identified by its internal identifier. However, a user can assign labels of any arbitrary Julia type to identify vertices. However, these labels can be used only externally. Internally, the vertices will still be identified by their integer ids. This is done has vertex label resolution can impose a significant overhead.  The following example demonstrates the Labelling API:  julia   using   Graft  julia   g   =   completegraph ( 10 )  Graph ( 10   vertices ,   90   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Set labels  1 ,  2  ...  10  to the vertices \n        setlabel! ( g ,   map ( string ,   1   :   10 ))  julia   # Translate labels into vertex identifiers \n        decode ( g ,   1 )  1  julia   # Decode a labelled edge \n        decode ( g ,   1 = 2 )  1 = 2  julia   # Translate vertex identifiers into labels \n        encode ( g ,   1 )  1  julia   # Encode an edge \n        encode ( g ,   1 = 2 )  1 = 2  julia   # Relabel a vertex \n        relabel! ( g ,   1 ,   ONE )  julia   # Remove all vertex labels (Use vertex identifiers instead) \n        setlabel! ( g )  julia   # Display all vertex labels (defaults to vertex identifiers in this case) \n        encode ( g )  10 - element   Array { Int64 , 1 }: \n   1 \n   2 \n   3 \n   4 \n   5 \n   6 \n   7 \n   8 \n   9 \n  10   Detailed documentation:  setlabel!(::Graph, ::Vector)\nsetlabel!(::Graph)\ndecode(::Graph, ::Any)\ndecode(::Graph, ::Pair)\nencode(::Graph, ::Int)\nencode(::Graph, ::Pair{Int,Int})\nencode(::Graph)\nrelabel!(::Graph, ::Int, ::Any)\nrelabel!(::Graph, ::AbstractVector{Int}, ::Vector)", 
            "title": "Labelling"
        }, 
        {
            "location": "/vdata/", 
            "text": "Vertex Metadata\n\n\nGraft supports the assignment of metadata to vertices, and adopts a tabular approach to storage. Vertex metadata is stored as an \nAbstractDataFrame\n. The vertices internal identifiers are used to index the vertex table.\n\n\nThe following example demonstrates vertex metadata:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \ncompletegraph\n(\n10\n);\n\n\n\njulia\n \nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n:\n10\n));\n\n\n\njulia\n \n# Create a new vertex property\n\n       \nsetvprop!\n(\ng\n,\n \n:,\n \n1\n \n:\n \n10\n,\n \n:\np1\n);\n\n\n\njulia\n \n# Fetch an entire column from the vertex table\n\n       \ngetvprop\n(\ng\n,\n \n:,\n \n:\np1\n)\n\n\n10\n-\nelement\n \nDataArrays\n.\nDataArray\n{\nInt64\n,\n1\n}:\n\n  \n1\n\n  \n2\n\n  \n3\n\n  \n4\n\n  \n5\n\n  \n6\n\n  \n7\n\n  \n8\n\n  \n9\n\n \n10\n\n\n\njulia\n \n# Modify the property\ns value for a subset of the vertices\n\n       \nsetvprop!\n(\ng\n,\n \n1\n:\n5\n,\n \n5\n,\n \n:\np1\n)\n\n\n5\n\n\n\njulia\n \n# Fetch the property\ns value for a subset of the vertices\n\n       \ngetvprop\n(\ng\n,\n \n1\n:\n5\n,\n \n:\np1\n)\n\n\n5\n-\nelement\n \nDataArrays\n.\nDataArray\n{\nInt64\n,\n1\n}:\n\n \n5\n\n \n5\n\n \n5\n\n \n5\n\n \n5\n\n\n\njulia\n \n# Create a new vertex property\n\n       \nsetvprop!\n(\ng\n,\n \n:,\n \n1\n,\n \n:\np2\n);\n\n\n\njulia\n \n# List all vertex properties in the graph\n\n       \nlistvprops\n(\ng\n)\n\n\n2\n-\nelement\n \nArray\n{\nSymbol\n,\n1\n}:\n\n \n:\np1\n\n \n:\np2\n\n\n\njulia\n \n# Display the vertex table\n\n       \nV\n \n=\n \nVertexDescriptor\n(\ng\n)\n\n\n\u2502\n \nVertexID\n \n\u2502\n \nLabels\n \n\u2502\n \np1\n \n\u2502\n \np2\n \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n        \n\u2502\n \n1\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n2\n        \n\u2502\n \n2\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n3\n        \n\u2502\n \n3\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n4\n        \n\u2502\n \n4\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n5\n        \n\u2502\n \n5\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n6\n        \n\u2502\n \n6\n    \n\u2502\n \n6\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n7\n        \n\u2502\n \n7\n    \n\u2502\n \n7\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n8\n        \n\u2502\n \n8\n    \n\u2502\n \n8\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n9\n        \n\u2502\n \n9\n    \n\u2502\n \n9\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n10\n       \n\u2502\n \n10\n   \n\u2502\n \n10\n \n\u2502\n \n1\n  \n\u2502\n\n\n\nVertex\n \n5\n\n\np1\n \n=\n \n5\n\n\np2\n \n=\n \n1\n\n\njulia\n \n# Examine a single labelled vertex\n\n       \nV\n[\n5\n]\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.listvprops\n \n \nFunction\n.\n\n\nList the column headers in the vertex dataframe \n\n\nsource\n\n\n#\n\n\nGraft.hasvprop\n \n \nFunction\n.\n\n\nCheck if the vertex dataframe has the input column \n\n\nsource\n\n\n#\n\n\nGraft.getvprop\n \n \nFunction\n.\n\n\nRetrieve vertex properties.\n\n\ngetvprop(g::Graph, v::VertexID, vprop::Symbol) -\n Fetch the value of a property for vertex v\n\n\nsource\n\n\ngetvprop(g::Graph, vs::VertexList, vprop::Symbol) -\n Fetch the value of a property for v in vs \n\n\nsource\n\n\ngetvprop(g::Graph, ::Colon, vprop::Symbol) -\n Fetch the value of a property for all verices \n\n\nsource\n\n\n#\n\n\nGraft.setvprop!\n \n \nFunction\n.\n\n\nSet vertex properties.\n\n\nsetvprop!(g::Graph, v::VertexID, val(s), vprop::Symbol) -\n Set a property for v\n\n\nsource\n\n\nsetvprop!(g::Graph, vs::VertexList, val(s), vprop::Symbol) -\n Set a property for v in vs \n\n\nsource\n\n\nsetvprop!(g::Graph, ::Colon, val(s), vprop::Symbol) -\n Set a property for all vertices in g \n\n\nsource", 
            "title": "Vertex Metadata"
        }, 
        {
            "location": "/vdata/#vertex-metadata", 
            "text": "Graft supports the assignment of metadata to vertices, and adopts a tabular approach to storage. Vertex metadata is stored as an  AbstractDataFrame . The vertices internal identifiers are used to index the vertex table.  The following example demonstrates vertex metadata:  julia   using   Graft  julia   g   =   completegraph ( 10 );  julia   setlabel! ( g ,   map ( string ,   1 : 10 ));  julia   # Create a new vertex property \n        setvprop! ( g ,   :,   1   :   10 ,   : p1 );  julia   # Fetch an entire column from the vertex table \n        getvprop ( g ,   :,   : p1 )  10 - element   DataArrays . DataArray { Int64 , 1 }: \n   1 \n   2 \n   3 \n   4 \n   5 \n   6 \n   7 \n   8 \n   9 \n  10  julia   # Modify the property s value for a subset of the vertices \n        setvprop! ( g ,   1 : 5 ,   5 ,   : p1 )  5  julia   # Fetch the property s value for a subset of the vertices \n        getvprop ( g ,   1 : 5 ,   : p1 )  5 - element   DataArrays . DataArray { Int64 , 1 }: \n  5 \n  5 \n  5 \n  5 \n  5  julia   # Create a new vertex property \n        setvprop! ( g ,   :,   1 ,   : p2 );  julia   # List all vertex properties in the graph \n        listvprops ( g )  2 - element   Array { Symbol , 1 }: \n  : p1 \n  : p2  julia   # Display the vertex table \n        V   =   VertexDescriptor ( g )  \u2502   VertexID   \u2502   Labels   \u2502   p1   \u2502   p2   \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524  \u2502   1          \u2502   1      \u2502   5    \u2502   1    \u2502  \u2502   2          \u2502   2      \u2502   5    \u2502   1    \u2502  \u2502   3          \u2502   3      \u2502   5    \u2502   1    \u2502  \u2502   4          \u2502   4      \u2502   5    \u2502   1    \u2502  \u2502   5          \u2502   5      \u2502   5    \u2502   1    \u2502  \u2502   6          \u2502   6      \u2502   6    \u2502   1    \u2502  \u2502   7          \u2502   7      \u2502   7    \u2502   1    \u2502  \u2502   8          \u2502   8      \u2502   8    \u2502   1    \u2502  \u2502   9          \u2502   9      \u2502   9    \u2502   1    \u2502  \u2502   10         \u2502   10     \u2502   10   \u2502   1    \u2502  Vertex   5  p1   =   5  p2   =   1  julia   # Examine a single labelled vertex \n        V [ 5 ]   Detailed documentation:  #  Graft.listvprops     Function .  List the column headers in the vertex dataframe   source  #  Graft.hasvprop     Function .  Check if the vertex dataframe has the input column   source  #  Graft.getvprop     Function .  Retrieve vertex properties.  getvprop(g::Graph, v::VertexID, vprop::Symbol) -  Fetch the value of a property for vertex v  source  getvprop(g::Graph, vs::VertexList, vprop::Symbol) -  Fetch the value of a property for v in vs   source  getvprop(g::Graph, ::Colon, vprop::Symbol) -  Fetch the value of a property for all verices   source  #  Graft.setvprop!     Function .  Set vertex properties.  setvprop!(g::Graph, v::VertexID, val(s), vprop::Symbol) -  Set a property for v  source  setvprop!(g::Graph, vs::VertexList, val(s), vprop::Symbol) -  Set a property for v in vs   source  setvprop!(g::Graph, ::Colon, val(s), vprop::Symbol) -  Set a property for all vertices in g   source", 
            "title": "Vertex Metadata"
        }, 
        {
            "location": "/edata/", 
            "text": "Edge Metadata\n\n\nGraft supports the assignment of metadata to vertices, and adopts a tabular approach to storage. Edge metadata is stored as an \nAbstractDataFrame\n. The adjacency matrix stores the row number for each edge, i.e. it serves as an edge to index map, or an index table to the edge metadata table.\n\n\nThe following example demonstrates edge metadata:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \ncompletegraph\n(\n10\n);\n\n\n\njulia\n \nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n));\n\n\n\njulia\n \neit\n \n=\n \nedges\n(\ng\n);\n\n\n\njulia\n \n# Create a new edge property\n\n       \nseteprop!\n(\ng\n,\n \n:,\n \n1\n \n:\n \n90\n,\n \n:\np1\n);\n\n\n\njulia\n \n# Fetch an entire column from the vertex table\n\n       \ngeteprop\n(\ng\n,\n \n:,\n \n:\np1\n)\n\n\n90\n-\nelement\n \nDataArrays\n.\nDataArray\n{\nInt64\n,\n1\n}:\n\n  \n1\n\n  \n2\n\n  \n3\n\n  \n4\n\n  \n5\n\n  \n6\n\n  \n7\n\n  \n8\n\n  \n9\n\n \n10\n\n  \n\u22ee\n\n \n82\n\n \n83\n\n \n84\n\n \n85\n\n \n86\n\n \n87\n\n \n88\n\n \n89\n\n \n90\n\n\n\njulia\n \n# Modify the property\ns value for a subset of the vertices\n\n       \nseteprop!\n(\ng\n,\n \neit\n[\n1\n:\n5\n],\n \n5\n,\n \n:\np1\n)\n\n\n5\n\n\n\njulia\n \n# Fetch the property\ns value for a subset of the vertices\n\n       \ngeteprop\n(\ng\n,\n \neit\n[\n1\n:\n5\n],\n \n:\np1\n)\n\n\n5\n-\nelement\n \nDataArrays\n.\nDataArray\n{\nInt64\n,\n1\n}:\n\n \n5\n\n \n5\n\n \n5\n\n \n5\n\n \n5\n\n\n\njulia\n \n# Create a new vertex property\n\n       \nseteprop!\n(\ng\n,\n \n:,\n \n1\n,\n \n:\np2\n);\n\n\n\njulia\n \n# List all vertex properties in the graph\n\n       \nlisteprops\n(\ng\n)\n\n\n2\n-\nelement\n \nArray\n{\nSymbol\n,\n1\n}:\n\n \n:\np1\n\n \n:\np2\n\n\n\njulia\n \n# Display the edge table\n\n       \nE\n \n=\n \nEdgeDescriptor\n(\ng\n)\n\n\n\u2502\n \nIndex\n \n\u2502\n \nSource\n \n\u2502\n \nTarget\n \n\u2502\n \np1\n \n\u2502\n \np2\n \n\u2502\n\n\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524\n\n\n\u2502\n \n1\n     \n\u2502\n \n1\n    \n\u2502\n \n2\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n2\n     \n\u2502\n \n1\n    \n\u2502\n \n3\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n3\n     \n\u2502\n \n1\n    \n\u2502\n \n4\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n4\n     \n\u2502\n \n1\n    \n\u2502\n \n5\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n5\n     \n\u2502\n \n1\n    \n\u2502\n \n6\n    \n\u2502\n \n5\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n6\n     \n\u2502\n \n1\n    \n\u2502\n \n7\n    \n\u2502\n \n6\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n7\n     \n\u2502\n \n1\n    \n\u2502\n \n8\n    \n\u2502\n \n7\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n8\n     \n\u2502\n \n1\n    \n\u2502\n \n9\n    \n\u2502\n \n8\n  \n\u2502\n \n1\n  \n\u2502\n\n\n\u22ee\n\n\n\u2502\n \n82\n    \n\u2502\n \n10\n   \n\u2502\n \n1\n    \n\u2502\n \n82\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n83\n    \n\u2502\n \n10\n   \n\u2502\n \n2\n    \n\u2502\n \n83\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n84\n    \n\u2502\n \n10\n   \n\u2502\n \n3\n    \n\u2502\n \n84\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n85\n    \n\u2502\n \n10\n   \n\u2502\n \n4\n    \n\u2502\n \n85\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n86\n    \n\u2502\n \n10\n   \n\u2502\n \n5\n    \n\u2502\n \n86\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n87\n    \n\u2502\n \n10\n   \n\u2502\n \n6\n    \n\u2502\n \n87\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n88\n    \n\u2502\n \n10\n   \n\u2502\n \n7\n    \n\u2502\n \n88\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n89\n    \n\u2502\n \n10\n   \n\u2502\n \n8\n    \n\u2502\n \n89\n \n\u2502\n \n1\n  \n\u2502\n\n\n\u2502\n \n90\n    \n\u2502\n \n10\n   \n\u2502\n \n9\n    \n\u2502\n \n90\n \n\u2502\n \n1\n  \n\u2502\n\n\n\nEdge\n \n1\n \n=\n \n5\n\n\np1\n \n=\n \n5\n\n\np2\n \n=\n \n1\n\n\njulia\n \n# Examine a single labelled edge\n\n       \nE\n[\n1\n,\n \n5\n]\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.listeprops\n \n \nFunction\n.\n\n\nList the column headers of the edge dataframe \n\n\nsource\n\n\n#\n\n\nGraft.haseprop\n \n \nFunction\n.\n\n\nCheck if the edge dataframe has the input edge property \n\n\nsource\n\n\n#\n\n\nGraft.geteprop\n \n \nFunction\n.\n\n\nRetrieve edge properties.\n\n\ngeteprop(g::Graph, e::EdgeID, eprop::Symbol) -\n Fetch the value of a property for edge e\n\n\nsource\n\n\ngeteprop(g::Graph, es::EdgeList, eprop::Symbol) -\n Fetch the value of a property for edge e in es \n\n\nsource\n\n\ngeteprop(g::Graph, ::Colon, eprop::Symbol) -\n Fetch the value of a property for all edges \n\n\nsource\n\n\n#\n\n\nGraft.seteprop!\n \n \nFunction\n.\n\n\nSet edge properties.\n\n\nseteprop!(g::Graph, e::EdgeID, val, eprop::Symbol) -\n Set a property for an edge e\n\n\nsource\n\n\nseteprop!(g::Graph, es::EdgeList, val(s), eprop::Symbol) -\n Set a property for e in es \n\n\nsource\n\n\nseteprop!(g::Graph, ::Colon, val(s), eprop::Symbol) \n\n\nsource", 
            "title": "Edge Metadata"
        }, 
        {
            "location": "/edata/#edge-metadata", 
            "text": "Graft supports the assignment of metadata to vertices, and adopts a tabular approach to storage. Edge metadata is stored as an  AbstractDataFrame . The adjacency matrix stores the row number for each edge, i.e. it serves as an edge to index map, or an index table to the edge metadata table.  The following example demonstrates edge metadata:  julia   using   Graft  julia   g   =   completegraph ( 10 );  julia   setlabel! ( g ,   map ( string ,   1   :   10 ));  julia   eit   =   edges ( g );  julia   # Create a new edge property \n        seteprop! ( g ,   :,   1   :   90 ,   : p1 );  julia   # Fetch an entire column from the vertex table \n        geteprop ( g ,   :,   : p1 )  90 - element   DataArrays . DataArray { Int64 , 1 }: \n   1 \n   2 \n   3 \n   4 \n   5 \n   6 \n   7 \n   8 \n   9 \n  10 \n   \u22ee \n  82 \n  83 \n  84 \n  85 \n  86 \n  87 \n  88 \n  89 \n  90  julia   # Modify the property s value for a subset of the vertices \n        seteprop! ( g ,   eit [ 1 : 5 ],   5 ,   : p1 )  5  julia   # Fetch the property s value for a subset of the vertices \n        geteprop ( g ,   eit [ 1 : 5 ],   : p1 )  5 - element   DataArrays . DataArray { Int64 , 1 }: \n  5 \n  5 \n  5 \n  5 \n  5  julia   # Create a new vertex property \n        seteprop! ( g ,   :,   1 ,   : p2 );  julia   # List all vertex properties in the graph \n        listeprops ( g )  2 - element   Array { Symbol , 1 }: \n  : p1 \n  : p2  julia   # Display the edge table \n        E   =   EdgeDescriptor ( g )  \u2502   Index   \u2502   Source   \u2502   Target   \u2502   p1   \u2502   p2   \u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2524  \u2502   1       \u2502   1      \u2502   2      \u2502   5    \u2502   1    \u2502  \u2502   2       \u2502   1      \u2502   3      \u2502   5    \u2502   1    \u2502  \u2502   3       \u2502   1      \u2502   4      \u2502   5    \u2502   1    \u2502  \u2502   4       \u2502   1      \u2502   5      \u2502   5    \u2502   1    \u2502  \u2502   5       \u2502   1      \u2502   6      \u2502   5    \u2502   1    \u2502  \u2502   6       \u2502   1      \u2502   7      \u2502   6    \u2502   1    \u2502  \u2502   7       \u2502   1      \u2502   8      \u2502   7    \u2502   1    \u2502  \u2502   8       \u2502   1      \u2502   9      \u2502   8    \u2502   1    \u2502  \u22ee  \u2502   82      \u2502   10     \u2502   1      \u2502   82   \u2502   1    \u2502  \u2502   83      \u2502   10     \u2502   2      \u2502   83   \u2502   1    \u2502  \u2502   84      \u2502   10     \u2502   3      \u2502   84   \u2502   1    \u2502  \u2502   85      \u2502   10     \u2502   4      \u2502   85   \u2502   1    \u2502  \u2502   86      \u2502   10     \u2502   5      \u2502   86   \u2502   1    \u2502  \u2502   87      \u2502   10     \u2502   6      \u2502   87   \u2502   1    \u2502  \u2502   88      \u2502   10     \u2502   7      \u2502   88   \u2502   1    \u2502  \u2502   89      \u2502   10     \u2502   8      \u2502   89   \u2502   1    \u2502  \u2502   90      \u2502   10     \u2502   9      \u2502   90   \u2502   1    \u2502  Edge   1   =   5  p1   =   5  p2   =   1  julia   # Examine a single labelled edge \n        E [ 1 ,   5 ]   Detailed documentation:  #  Graft.listeprops     Function .  List the column headers of the edge dataframe   source  #  Graft.haseprop     Function .  Check if the edge dataframe has the input edge property   source  #  Graft.geteprop     Function .  Retrieve edge properties.  geteprop(g::Graph, e::EdgeID, eprop::Symbol) -  Fetch the value of a property for edge e  source  geteprop(g::Graph, es::EdgeList, eprop::Symbol) -  Fetch the value of a property for edge e in es   source  geteprop(g::Graph, ::Colon, eprop::Symbol) -  Fetch the value of a property for all edges   source  #  Graft.seteprop!     Function .  Set edge properties.  seteprop!(g::Graph, e::EdgeID, val, eprop::Symbol) -  Set a property for an edge e  source  seteprop!(g::Graph, es::EdgeList, val(s), eprop::Symbol) -  Set a property for e in es   source  seteprop!(g::Graph, ::Colon, val(s), eprop::Symbol)   source", 
            "title": "Edge Metadata"
        }, 
        {
            "location": "/queries/", 
            "text": "Queries\n\n\nThe query macro is used to execute graph queries in a pipelined manner.The main functionalities provided by the query macro are:\n\n\n\n\neachvertex:\n\n\nThis abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.\n\n\nFor example, \n@query g |\n eachvertex(v.p1 + v.p2 * v.p3)\n executes the expression \nv.p1 + v.p2 * v.p3\n on every vertex in the result from the previous pipeline stage. Here, \nv.p1\n denotes the value of property \np1\n for every vertex.\n\n\n\n\neachedge:\n\n\nThis abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.\n\n\nFor example, \n@query g |\n eachedge(e.p1 + s.p1 + t.p1)\n executes the expression \ne.p1 + s.p1 + t.p1\n on every edge in the graph. Here, 'e.p1' denotes the value of property \np1\n for every edge in the graph. Since each edge has a source vertex \ns\n and a target vertex \nt\n, the properties of these vertices can be used in the expression as shown by \ns.p1\n and \nt.p1\n.\n\n\n\n\nfilter\n\n\nThis abstraction is used to compute a subgraph of the input from the previous pipeline stage, on the given conditions.\n\n\nFor example, \n@query g |\n filter(v.p1 \n 5, v.p1 \n v.p2, e.p1 \n 5)\n uses the three filter conditions provided to compute a subgraph. Currently only binary comparisons are supported, so comparisons like 1 \n v.p1 \n v.p2 will not work. Instead you can supply multiple conditions as separate arguments.\n\n\n\n\nselect\n\n\nThis abstraction is used to compute a subgraph of the input from the previous pipeline state, for a subset of vertex and or edge properties.\n\n\nFor example, \n@query g |\n select(v.p1, v.p3, e.p1)\n preserves only vertex properties \np1\n,\np2\n and edge property \np1\n.\n\n\n\n\nExamples\n\n\nThe abstractions can be chained together using the pipe notation, so that the output of one stage becomes the input to the next.\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \npropgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\nGraph\n(\n10\n \nvertices\n,\n \n90\n \nedges\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Run a filter using vertex properties\n\n       \n@\nquery\n \ng\n \n|\n \nfilter\n(\n0.5\n \n=\n \nv\n.\np1\n,\n \nv\n.\np1\n \n \nv\n.\np2\n)\n\n\nGraph\n(\n1\n \nvertices\n,\n \n0\n \nedges\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Run a filter using source and target properties\n\n       \n@\nquery\n \ng\n \n|\n \nfilter\n(\ns\n.\np1\n \n \nt\n.\np2\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n47\n \nedges\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Run filter using edge properties\n\n       \n@\nquery\n \ng\n \n|\n \nfilter\n(\ne\n.\np1\n \n \n0.7\n)\n\n\nGraph\n(\n10\n \nvertices\n,\n \n67\n \nedges\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Chain filter expressions\n\n       \n@\nquery\n \ng\n \n|\n \nfilter\n(\nv\n.\np1\n \n \nv\n.\np2\n)\n \n|\n \nfilter\n(\ne\n.\np1\n \n \ne\n.\np1\n)\n\n\nGraph\n(\n6\n \nvertices\n,\n \n0\n \nedges\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n,:\np2\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Select properties\n\n       \n@\nquery\n \ng\n \n|\n \nfilter\n(\nv\n.\np1\n \n \nv\n.\np2\n)\n \n|\n \nselect\n(\nv\n.\np2\n,\n \ne\n.\np1\n)\n\n\nGraph\n(\n6\n \nvertices\n,\n \n30\n \nedges\n,\n \nSymbol\n[:\np2\n]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\np1\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Run an expression on each vertex\n\n       \n@\nquery\n \ng\n \n|\n \neachvertex\n(\nv\n.\np1\n \n+\n \nv\n.\np2\n)\n\n\n10\n-\nelement\n \nDataArrays\n.\nDataArray\n{\nFloat64\n,\n1\n}:\n\n \n0.395994\n\n \n0.835485\n\n \n1.21451\n\n \n1.28265\n\n \n0.42479\n\n \n1.0061\n\n \n0.238069\n\n \n1.3152\n\n \n1.50935\n\n \n1.12792\n\n\n\njulia\n \n# Run an expression on each edge\n\n       \n@\nquery\n \ng\n \n|\n \nfilter\n(\ne\n.\np1\n \n \ne\n.\np2\n)\n \n|\n \neachedge\n(\ne\n.\np1\n \n+\n \ne\n.\np2\n)\n\n\n40\n-\nelement\n \nDataArrays\n.\nDataArray\n{\nFloat64\n,\n1\n}:\n\n \n0.998767\n\n \n0.282689\n\n \n0.620956\n\n \n0.708976\n\n \n0.732114\n\n \n1.35927\n\n \n0.876062\n\n \n1.38501\n\n \n1.33557\n\n \n1.72333\n\n \n\u22ee\n\n \n0.481083\n\n \n0.975415\n\n \n1.35129\n\n \n0.784294\n\n \n1.32318\n\n \n0.783685\n\n \n0.389393\n\n \n1.1968\n\n \n0.945768\n\n\n\n\n\n\nThe entire query is parsed into a DAG, using a recursive descent parser, and then executed in a bottom up manner. The results of intermediate nodes, and fetched vertex properties are cached to avoid redundant computations.", 
            "title": "Query Macro"
        }, 
        {
            "location": "/queries/#queries", 
            "text": "The query macro is used to execute graph queries in a pipelined manner.The main functionalities provided by the query macro are:", 
            "title": "Queries"
        }, 
        {
            "location": "/queries/#eachvertex", 
            "text": "This abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.  For example,  @query g |  eachvertex(v.p1 + v.p2 * v.p3)  executes the expression  v.p1 + v.p2 * v.p3  on every vertex in the result from the previous pipeline stage. Here,  v.p1  denotes the value of property  p1  for every vertex.", 
            "title": "eachvertex:"
        }, 
        {
            "location": "/queries/#eachedge", 
            "text": "This abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.  For example,  @query g |  eachedge(e.p1 + s.p1 + t.p1)  executes the expression  e.p1 + s.p1 + t.p1  on every edge in the graph. Here, 'e.p1' denotes the value of property  p1  for every edge in the graph. Since each edge has a source vertex  s  and a target vertex  t , the properties of these vertices can be used in the expression as shown by  s.p1  and  t.p1 .", 
            "title": "eachedge:"
        }, 
        {
            "location": "/queries/#filter", 
            "text": "This abstraction is used to compute a subgraph of the input from the previous pipeline stage, on the given conditions.  For example,  @query g |  filter(v.p1   5, v.p1   v.p2, e.p1   5)  uses the three filter conditions provided to compute a subgraph. Currently only binary comparisons are supported, so comparisons like 1   v.p1   v.p2 will not work. Instead you can supply multiple conditions as separate arguments.", 
            "title": "filter"
        }, 
        {
            "location": "/queries/#select", 
            "text": "This abstraction is used to compute a subgraph of the input from the previous pipeline state, for a subset of vertex and or edge properties.  For example,  @query g |  select(v.p1, v.p3, e.p1)  preserves only vertex properties  p1 , p2  and edge property  p1 .", 
            "title": "select"
        }, 
        {
            "location": "/queries/#examples", 
            "text": "The abstractions can be chained together using the pipe notation, so that the output of one stage becomes the input to the next.  julia   using   Graft  julia   g   =   propgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  Graph ( 10   vertices ,   90   edges ,   Symbol [: p1 ,: p2 ]   vertex   properties ,   Symbol [: p1 ,: p2 ]   edge   properties )  julia   # Run a filter using vertex properties \n        @ query   g   |   filter ( 0.5   =   v . p1 ,   v . p1     v . p2 )  Graph ( 1   vertices ,   0   edges ,   Symbol [: p1 ,: p2 ]   vertex   properties ,   Symbol [: p1 ,: p2 ]   edge   properties )  julia   # Run a filter using source and target properties \n        @ query   g   |   filter ( s . p1     t . p2 )  Graph ( 10   vertices ,   47   edges ,   Symbol [: p1 ,: p2 ]   vertex   properties ,   Symbol [: p1 ,: p2 ]   edge   properties )  julia   # Run filter using edge properties \n        @ query   g   |   filter ( e . p1     0.7 )  Graph ( 10   vertices ,   67   edges ,   Symbol [: p1 ,: p2 ]   vertex   properties ,   Symbol [: p1 ,: p2 ]   edge   properties )  julia   # Chain filter expressions \n        @ query   g   |   filter ( v . p1     v . p2 )   |   filter ( e . p1     e . p1 )  Graph ( 6   vertices ,   0   edges ,   Symbol [: p1 ,: p2 ]   vertex   properties ,   Symbol [: p1 ,: p2 ]   edge   properties )  julia   # Select properties \n        @ query   g   |   filter ( v . p1     v . p2 )   |   select ( v . p2 ,   e . p1 )  Graph ( 6   vertices ,   30   edges ,   Symbol [: p2 ]   vertex   properties ,   Symbol [: p1 ]   edge   properties )  julia   # Run an expression on each vertex \n        @ query   g   |   eachvertex ( v . p1   +   v . p2 )  10 - element   DataArrays . DataArray { Float64 , 1 }: \n  0.395994 \n  0.835485 \n  1.21451 \n  1.28265 \n  0.42479 \n  1.0061 \n  0.238069 \n  1.3152 \n  1.50935 \n  1.12792  julia   # Run an expression on each edge \n        @ query   g   |   filter ( e . p1     e . p2 )   |   eachedge ( e . p1   +   e . p2 )  40 - element   DataArrays . DataArray { Float64 , 1 }: \n  0.998767 \n  0.282689 \n  0.620956 \n  0.708976 \n  0.732114 \n  1.35927 \n  0.876062 \n  1.38501 \n  1.33557 \n  1.72333 \n  \u22ee \n  0.481083 \n  0.975415 \n  1.35129 \n  0.784294 \n  1.32318 \n  0.783685 \n  0.389393 \n  1.1968 \n  0.945768   The entire query is parsed into a DAG, using a recursive descent parser, and then executed in a bottom up manner. The results of intermediate nodes, and fetched vertex properties are cached to avoid redundant computations.", 
            "title": "Examples"
        }, 
        {
            "location": "/hopgraph/", 
            "text": "Hop Subgraphs\n\n\nGraft provides methods to construct subgraphs using traversals. Consider the following example:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \nGraph\n(\n20\n,\n \n60\n)\n\n\nGraph\n(\n20\n \nvertices\n,\n \n53\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n20\n))\n\n\n\njulia\n \n# Get a list of vertices, at a distance of 2-3 hops from vertex \n1\n\n       \nhoplist\n(\ng\n,\n \n1\n,\n \n2\n,\n \n3\n)\n\n\n12\n-\nelement\n \nArray\n{\nString\n,\n1\n}:\n\n \n12\n\n \n13\n\n \n17\n\n \n7\n\n \n8\n\n \n9\n\n \n14\n\n \n15\n\n \n3\n\n \n20\n\n \n10\n\n \n16\n\n\n\njulia\n \n# Get a BFS tree starting from the input vertex\n\n       \n# and terminating at 3 hops distance. Can be used to visualize\n\n       \n# a BFS traversal\n\n       \nhoptree\n(\ng\n,\n \n1\n,\n \n3\n)\n\n\nGraph\n(\n18\n \nvertices\n,\n \n17\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Get a subgraph containing all vertices within 3 hops distance,\n\n       \n# and all edges between them. Can be used to construct the\n\n       \n# neighborhood of a vertex\n\n       \nhopgraph\n(\ng\n,\n \n1\n,\n \n3\n)\n\n\nGraph\n(\n18\n \nvertices\n,\n \n50\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.hoplist\n \n \nFunction\n.\n\n\nGet a list of vertices at a certain hop distance from a labelled vertex\n\n\nsource\n\n\n#\n\n\nGraft.hoptree\n \n \nFunction\n.\n\n\nGet the bfs tree starting from the input labelled vertex, and ending at a certain hop distance\n\n\nsource\n\n\n#\n\n\nGraft.hopgraph\n \n \nFunction\n.\n\n\nGet a subgraph containing vertices and edges within a certain hop distance from the input labelled vertex\n\n\nsource", 
            "title": "Hop Subgraphs"
        }, 
        {
            "location": "/hopgraph/#hop-subgraphs", 
            "text": "Graft provides methods to construct subgraphs using traversals. Consider the following example:  julia   using   Graft  julia   g   =   Graph ( 20 ,   60 )  Graph ( 20   vertices ,   53   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   setlabel! ( g ,   map ( string ,   1   :   20 ))  julia   # Get a list of vertices, at a distance of 2-3 hops from vertex  1 \n        hoplist ( g ,   1 ,   2 ,   3 )  12 - element   Array { String , 1 }: \n  12 \n  13 \n  17 \n  7 \n  8 \n  9 \n  14 \n  15 \n  3 \n  20 \n  10 \n  16  julia   # Get a BFS tree starting from the input vertex \n        # and terminating at 3 hops distance. Can be used to visualize \n        # a BFS traversal \n        hoptree ( g ,   1 ,   3 )  Graph ( 18   vertices ,   17   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Get a subgraph containing all vertices within 3 hops distance, \n        # and all edges between them. Can be used to construct the \n        # neighborhood of a vertex \n        hopgraph ( g ,   1 ,   3 )  Graph ( 18   vertices ,   50   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )   Detailed documentation:  #  Graft.hoplist     Function .  Get a list of vertices at a certain hop distance from a labelled vertex  source  #  Graft.hoptree     Function .  Get the bfs tree starting from the input labelled vertex, and ending at a certain hop distance  source  #  Graft.hopgraph     Function .  Get a subgraph containing vertices and edges within a certain hop distance from the input labelled vertex  source", 
            "title": "Hop Subgraphs"
        }, 
        {
            "location": "/graphio/", 
            "text": "Graph IO\n\n\nGraft will eventually support several file formats for reading and writing graphs. However currently, only a GraphCSV supported. The format is described below\n\n\nThe input file should contain data in the following format:\n\nnum_vertices\n,\nnum_edges\n,\nlabel_type\n(1)\n\nvprop1\n,\nvprop2\n,\nvprop3\n... (2)\n\nvproptype1\n,\nvproptype2\n,\nvproptype3\n... (3)\n\neprop1\n,\neprop2\n,\neprop3\n... (4)\n\neproptype1\n,\neproptype2\n,\neproptype3\n... (5)\n\nvertex_label\n,\nval_1\n,\nval_2\n,\nval_3\n ... (6)\n.\n.\n.\n\nvertex_label\n,\nval_1\n,\nval_2\n,\nval_3\n ... (Nv + 5)\n\nfrom_vertex_label\n,\nto_vertex_label\n,\nval_1\n,\nval_2\n ... (Nv + 6)\n.\n.\n.\n\nfrom_vertex_label\n,\nto_vertex_label\n,\nval_1\n,\nval_2\n ... (Nv + Ne + 5)\nEOF\n\n\n\n\n\ng\n \n=\n \nloadgraph\n(\ngraph.txt\n)\n\n\n\nstoregraph\n(\ng\n,\n \ngraph.txt\n)\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.loadgraph\n \n \nFunction\n.\n\n\nParse a text file GraphCSV format\n\n\nsource\n\n\n#\n\n\nGraft.storegraph\n \n \nFunction\n.\n\n\nWrite a graph to file \n\n\nsource", 
            "title": "File IO"
        }, 
        {
            "location": "/graphio/#graph-io", 
            "text": "Graft will eventually support several file formats for reading and writing graphs. However currently, only a GraphCSV supported. The format is described below  The input file should contain data in the following format: num_vertices , num_edges , label_type (1) vprop1 , vprop2 , vprop3 ... (2) vproptype1 , vproptype2 , vproptype3 ... (3) eprop1 , eprop2 , eprop3 ... (4) eproptype1 , eproptype2 , eproptype3 ... (5) vertex_label , val_1 , val_2 , val_3  ... (6)\n.\n.\n. vertex_label , val_1 , val_2 , val_3  ... (Nv + 5) from_vertex_label , to_vertex_label , val_1 , val_2  ... (Nv + 6)\n.\n.\n. from_vertex_label , to_vertex_label , val_1 , val_2  ... (Nv + Ne + 5)\nEOF  g   =   loadgraph ( graph.txt )  storegraph ( g ,   graph.txt )   Detailed documentation:  #  Graft.loadgraph     Function .  Parse a text file GraphCSV format  source  #  Graft.storegraph     Function .  Write a graph to file   source", 
            "title": "Graph IO"
        }, 
        {
            "location": "/export/", 
            "text": "Export API\n\n\nGraft supports the export of adjacency matrices and metadata, for use in Graph libraries such as LightGraphs. The example below shows how a workflow involving LightGraphs algorithms may look like.\n\n\nusing\n \nGraft\n\n\nimport\n \nLightGraphs\n\n\n\ng\n \n=\n \nGraph\n(\n10\n^\n3\n,\n \n5\n \n*\n \n10\n^\n4\n);\n\n\nsetlabel!\n(\ng\n,\n \nmap\n(\nstring\n,\n \n1\n \n:\n \n10\n^\n3\n));\n\n\n\njulia\n \n# Set edge properties\n\n       \nseteprop!\n(\ng\n,\n \n:,\n \nrand\n(\nne\n(\ng\n)),\n \n:\nweight\n);\n\n\n\njulia\n \nseteprop!\n(\ng\n,\n \n:,\n \nrand\n(\n1\n \n:\n \n10\n,\n \nne\n(\ng\n)),\n \n:\ndist\n);\n\n\n\n\njulia\n \n# Discard low weight edges\n\n       \ng\n \n=\n \n@\nquery\n(\ng\n \n|\n \nfilter\n(\ne\n.\nweight\n \n=\n \n0.5\n))\n\n\nGraph\n(\n1000\n \nvertices\n,\n \n24939\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[:\nweight\n,:\ndist\n]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Export g\ns adjacency matrix\n\n       \nM\n \n=\n \nexport_adjacency\n(\ng\n)\n\n \n1000\n\u00d71000\n \nsparse\n \nmatrix\n \nwith\n \n24939\n \nInt64\n \nnonzero\n \nentries\n:\n\n    \n[\n33\n  \n,\n    \n1\n]\n  \n=\n  \n1\n\n    \n[\n63\n  \n,\n    \n1\n]\n  \n=\n  \n2\n\n    \n[\n131\n \n,\n    \n1\n]\n  \n=\n  \n3\n\n    \n[\n161\n \n,\n    \n1\n]\n  \n=\n  \n4\n\n    \n[\n224\n \n,\n    \n1\n]\n  \n=\n  \n5\n\n    \n[\n339\n \n,\n    \n1\n]\n  \n=\n  \n6\n\n    \n[\n380\n \n,\n    \n1\n]\n  \n=\n  \n7\n\n    \n[\n491\n \n,\n    \n1\n]\n  \n=\n  \n8\n\n    \n[\n667\n \n,\n    \n1\n]\n  \n=\n  \n9\n\n    \n\u22ee\n\n    \n[\n524\n \n,\n \n1000\n]\n  \n=\n  \n24931\n\n    \n[\n615\n \n,\n \n1000\n]\n  \n=\n  \n24932\n\n    \n[\n624\n \n,\n \n1000\n]\n  \n=\n  \n24933\n\n    \n[\n628\n \n,\n \n1000\n]\n  \n=\n  \n24934\n\n    \n[\n638\n \n,\n \n1000\n]\n  \n=\n  \n24935\n\n    \n[\n846\n \n,\n \n1000\n]\n  \n=\n  \n24936\n\n    \n[\n870\n \n,\n \n1000\n]\n  \n=\n  \n24937\n\n    \n[\n871\n \n,\n \n1000\n]\n  \n=\n  \n24938\n\n    \n[\n956\n \n,\n \n1000\n]\n  \n=\n  \n24939\n\n\n\njulia\n \n# Export g\ns edge dists\n\n       \nD\n \n=\n \nexport_edge_property\n(\ng\n,\n \n:\ndist\n)\n\n \n1000\n\u00d71000\n \nsparse\n \nmatrix\n \nwith\n \n24939\n \nInt64\n \nnonzero\n \nentries\n:\n\n    \n[\n33\n  \n,\n    \n1\n]\n  \n=\n  \n4\n\n    \n[\n63\n  \n,\n    \n1\n]\n  \n=\n  \n4\n\n    \n[\n131\n \n,\n    \n1\n]\n  \n=\n  \n4\n\n    \n[\n161\n \n,\n    \n1\n]\n  \n=\n  \n4\n\n    \n[\n224\n \n,\n    \n1\n]\n  \n=\n  \n4\n\n    \n[\n339\n \n,\n    \n1\n]\n  \n=\n  \n8\n\n    \n[\n380\n \n,\n    \n1\n]\n  \n=\n  \n6\n\n    \n[\n491\n \n,\n    \n1\n]\n  \n=\n  \n1\n\n    \n[\n667\n \n,\n    \n1\n]\n  \n=\n  \n8\n\n    \n\u22ee\n\n    \n[\n615\n \n,\n \n1000\n]\n  \n=\n  \n5\n\n    \n[\n624\n \n,\n \n1000\n]\n  \n=\n  \n3\n\n    \n[\n628\n \n,\n \n1000\n]\n  \n=\n  \n5\n\n    \n[\n638\n \n,\n \n1000\n]\n  \n=\n  \n2\n\n    \n[\n846\n \n,\n \n1000\n]\n  \n=\n  \n1\n\n    \n[\n870\n \n,\n \n1000\n]\n  \n=\n  \n7\n\n    \n[\n871\n \n,\n \n1000\n]\n  \n=\n  \n5\n\n    \n[\n956\n \n,\n \n1000\n]\n  \n=\n  \n4\n\n\n\njulia\n \n# Construct a LightGraphs graph\n\n       \nlg\n \n=\n \nLightGraphs\n.\nDiGraph\n(\nM\n)\n\n\n{\n1000\n,\n \n24939\n}\n \ndirected\n \ngraph\n\n\n\njulia\n \n# Calculate all pair shortest paths\n\n       \nsdists\n \n=\n \nLightGraphs\n.\nfloyd_warshall_shortest_paths\n(\nlg\n,\n \nD\n)\n.\ndists\n\n\n1000\n\u00d71000\n \nArray\n{\nInt64\n,\n2\n}:\n\n\n5\n  \n5\n  \n4\n  \n5\n  \n6\n  \n6\n  \n6\n  \n6\n  \n6\n  \n6\n  \n6\n \n\u2026\n \n4\n  \n6\n  \n4\n  \n6\n  \n5\n  \n6\n  \n4\n  \n5\n  \n7\n  \n5\n  \n3\n  \n6\n\n\n6\n  \n7\n  \n7\n  \n6\n  \n6\n  \n7\n  \n7\n  \n4\n  \n6\n  \n4\n  \n6\n   \n6\n  \n7\n  \n2\n  \n6\n  \n7\n  \n6\n  \n6\n  \n6\n  \n7\n  \n6\n  \n5\n  \n6\n\n\n7\n  \n6\n  \n7\n  \n5\n  \n8\n  \n5\n  \n6\n  \n7\n  \n6\n  \n7\n  \n5\n   \n5\n  \n7\n  \n6\n  \n6\n  \n7\n  \n7\n  \n8\n  \n5\n  \n7\n  \n6\n  \n6\n  \n7\n\n\n5\n  \n7\n  \n5\n  \n4\n  \n7\n  \n6\n  \n6\n  \n7\n  \n6\n  \n6\n  \n5\n \n\u2026\n \n6\n  \n6\n  \n3\n  \n6\n  \n5\n  \n4\n  \n7\n  \n6\n  \n6\n  \n7\n  \n5\n  \n5\n\n\n4\n  \n7\n  \n7\n  \n3\n  \n7\n  \n5\n  \n7\n  \n6\n  \n2\n  \n4\n  \n6\n   \n4\n  \n6\n  \n5\n  \n6\n  \n5\n  \n7\n  \n7\n  \n7\n  \n6\n  \n6\n  \n6\n  \n6\n\n\n7\n  \n7\n  \n7\n  \n5\n  \n7\n  \n6\n  \n7\n  \n6\n  \n5\n  \n4\n  \n5\n   \n4\n  \n7\n  \n7\n  \n6\n  \n6\n  \n8\n  \n6\n  \n6\n  \n6\n  \n5\n  \n6\n  \n5\n\n\n7\n  \n6\n  \n7\n  \n6\n  \n8\n  \n5\n  \n7\n  \n7\n  \n8\n  \n8\n  \n6\n \n\u2026\n \n7\n  \n7\n  \n7\n  \n6\n  \n8\n  \n8\n  \n9\n  \n7\n  \n9\n  \n7\n  \n7\n  \n5\n\n\n7\n  \n4\n  \n7\n  \n5\n  \n4\n  \n5\n  \n4\n  \n6\n  \n6\n  \n8\n  \n6\n   \n4\n  \n7\n  \n6\n  \n5\n  \n7\n  \n6\n  \n7\n  \n6\n  \n6\n  \n5\n  \n7\n  \n5\n\n\n7\n  \n6\n  \n6\n  \n7\n  \n4\n  \n5\n  \n5\n  \n6\n  \n7\n  \n9\n  \n6\n   \n7\n  \n4\n  \n6\n  \n6\n  \n7\n  \n7\n  \n6\n  \n6\n  \n7\n  \n7\n  \n5\n  \n7\n\n\n7\n  \n5\n  \n7\n  \n5\n  \n6\n  \n5\n  \n7\n  \n5\n  \n6\n  \n5\n  \n6\n \n\u2026\n \n5\n  \n6\n  \n5\n  \n4\n  \n4\n  \n6\n  \n7\n  \n4\n  \n7\n  \n5\n  \n5\n  \n3\n\n\n5\n  \n3\n  \n6\n  \n5\n  \n7\n  \n5\n  \n6\n  \n4\n  \n6\n  \n7\n  \n6\n   \n5\n  \n6\n  \n4\n  \n6\n  \n5\n  \n5\n  \n4\n  \n5\n  \n6\n  \n7\n  \n5\n  \n6\n\n\n4\n  \n5\n  \n6\n  \n5\n  \n5\n  \n5\n  \n6\n  \n5\n  \n3\n  \n4\n  \n6\n   \n5\n  \n6\n  \n3\n  \n7\n  \n6\n  \n7\n  \n6\n  \n6\n  \n5\n  \n4\n  \n5\n  \n6\n\n\n\u22ee\n     \n\u22ee\n      \n\u22ee\n     \n\u22ee\n      \n\u22ee\n      \n\u22f1\n    \n\u22ee\n     \n\u22ee\n      \n\u22ee\n     \n\u22ee\n     \n\u22ee\n      \n\u22ee\n\n\n8\n  \n8\n  \n5\n  \n6\n  \n7\n  \n6\n  \n6\n  \n3\n  \n6\n  \n4\n  \n7\n   \n7\n  \n6\n  \n6\n  \n7\n  \n4\n  \n5\n  \n3\n  \n8\n  \n3\n  \n5\n  \n6\n  \n4\n\n\n7\n  \n7\n  \n6\n  \n7\n  \n4\n  \n3\n  \n6\n  \n5\n  \n7\n  \n5\n  \n5\n   \n6\n  \n5\n  \n7\n  \n5\n  \n4\n  \n6\n  \n5\n  \n7\n  \n4\n  \n6\n  \n7\n  \n6\n\n\n6\n  \n7\n  \n7\n  \n7\n  \n5\n  \n7\n  \n6\n  \n3\n  \n5\n  \n7\n  \n7\n \n\u2026\n  \n7\n  \n5\n  \n6\n  \n6\n  \n5\n  \n7\n  \n5\n  \n6\n  \n5\n  \n6\n  \n5\n  \n5\n\n\n6\n  \n6\n  \n7\n  \n7\n  \n6\n  \n3\n  \n5\n  \n6\n  \n5\n  \n7\n  \n4\n   \n7\n  \n7\n  \n5\n  \n5\n  \n3\n  \n6\n  \n5\n  \n7\n  \n7\n  \n6\n  \n7\n  \n4\n\n\n8\n  \n7\n  \n5\n  \n5\n  \n4\n  \n7\n  \n7\n  \n6\n  \n6\n  \n7\n  \n8\n   \n8\n  \n8\n  \n5\n  \n5\n  \n7\n  \n5\n  \n8\n  \n6\n  \n7\n  \n4\n  \n7\n  \n8\n\n\n6\n  \n6\n  \n6\n  \n7\n  \n5\n  \n6\n  \n5\n  \n6\n  \n4\n  \n6\n  \n5\n \n\u2026\n \n6\n  \n7\n  \n7\n  \n6\n  \n3\n  \n8\n  \n5\n  \n8\n  \n6\n  \n5\n  \n7\n  \n6\n\n\n7\n  \n6\n  \n6\n  \n5\n  \n5\n  \n5\n  \n6\n  \n6\n  \n7\n  \n7\n  \n5\n   \n6\n  \n7\n  \n6\n  \n5\n  \n3\n  \n5\n  \n5\n  \n8\n  \n5\n  \n5\n  \n6\n  \n6\n\n\n6\n  \n7\n  \n5\n  \n6\n  \n7\n  \n6\n  \n6\n  \n6\n  \n7\n  \n6\n  \n7\n   \n3\n  \n4\n  \n8\n  \n5\n  \n6\n  \n6\n  \n4\n  \n5\n  \n7\n  \n5\n  \n4\n  \n5\n\n\n9\n  \n9\n  \n7\n  \n9\n  \n7\n  \n8\n  \n7\n  \n6\n  \n9\n  \n9\n  \n7\n \n\u2026\n \n9\n  \n6\n  \n9\n  \n9\n  \n8\n  \n8\n  \n6\n  \n9\n  \n7\n  \n7\n  \n0\n  \n7\n\n\n8\n  \n8\n  \n8\n  \n7\n  \n7\n  \n8\n  \n6\n  \n7\n  \n8\n  \n7\n  \n8\n   \n8\n  \n8\n  \n4\n  \n6\n  \n8\n  \n7\n  \n7\n  \n9\n  \n8\n  \n8\n  \n9\n  \n8\n\n\n6\n  \n5\n  \n6\n  \n6\n  \n3\n  \n5\n  \n7\n  \n6\n  \n7\n  \n6\n  \n6\n   \n7\n  \n7\n  \n7\n  \n5\n  \n4\n  \n7\n  \n7\n  \n7\n  \n6\n  \n7\n  \n4\n  \n8\n\n\n7\n  \n6\n  \n6\n  \n4\n  \n6\n  \n6\n  \n4\n  \n5\n  \n7\n  \n7\n  \n6\n \n\u2026\n \n7\n  \n6\n  \n5\n  \n6\n  \n3\n  \n6\n  \n5\n  \n5\n  \n6\n  \n5\n  \n8\n  \n6\n\n\n\njulia\n \n# Find the shortest distances for edge pairs\n\n       \nsdists\n \n=\n \n[\nsdists\n[\ne\n.\nsecond\n,\n \ne\n.\nfirst\n]\n \nfor\n \ne\n \nin\n \nedges\n(\ng\n)];\n\n\n\njulia\n \n# Make the shortest distances an edge proeprty\n\n       \nseteprop!\n(\ng\n,\n \n:,\n \nsdists\n,\n \n:\nshortest_distance\n);\n\n\n\njulia\n \n# Calculate the graph\ns betweenness centrality\n\n       \ncentrality\n \n=\n \nLightGraphs\n.\nbetweenness_centrality\n(\nlg\n);\n\n\n\njulia\n \n# Make the centrality calculate above a vertex property\n\n       \nsetvprop!\n(\ng\n,\n \n:,\n \ncentrality\n,\n \n:\ncentrality\n)\n\n\n\njulia\n \n# Display the vertex table\n\n       \nVertexDescriptor\n(\ng\n)\n\n \n\u2502\n \nVertexID\n \n\u2502\n \nLabels\n \n\u2502\n \ncentrality\n  \n\u2502\n\n \n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n \n\u2502\n \n1\n        \n\u2502\n \n1\n      \n\u2502\n \n0.00100559\n  \n\u2502\n\n \n\u2502\n \n2\n        \n\u2502\n \n2\n      \n\u2502\n \n0.00115523\n  \n\u2502\n\n \n\u2502\n \n3\n        \n\u2502\n \n3\n      \n\u2502\n \n0.00139773\n  \n\u2502\n\n \n\u2502\n \n4\n        \n\u2502\n \n4\n      \n\u2502\n \n0.00161647\n  \n\u2502\n\n \n\u2502\n \n5\n        \n\u2502\n \n5\n      \n\u2502\n \n0.00184465\n  \n\u2502\n\n \n\u2502\n \n6\n        \n\u2502\n \n6\n      \n\u2502\n \n0.00152136\n  \n\u2502\n\n \n\u2502\n \n7\n        \n\u2502\n \n7\n      \n\u2502\n \n0.00113189\n  \n\u2502\n\n \n\u2502\n \n8\n        \n\u2502\n \n8\n      \n\u2502\n \n0.00147083\n  \n\u2502\n\n \n\u22ee\n\n \n\u2502\n \n990\n      \n\u2502\n \n990\n    \n\u2502\n \n0.00233637\n  \n\u2502\n\n \n\u2502\n \n991\n      \n\u2502\n \n991\n    \n\u2502\n \n0.00101592\n  \n\u2502\n\n \n\u2502\n \n992\n      \n\u2502\n \n992\n    \n\u2502\n \n0.00152453\n  \n\u2502\n\n \n\u2502\n \n993\n      \n\u2502\n \n993\n    \n\u2502\n \n0.00124928\n  \n\u2502\n\n \n\u2502\n \n994\n      \n\u2502\n \n994\n    \n\u2502\n \n0.000931563\n \n\u2502\n\n \n\u2502\n \n995\n      \n\u2502\n \n995\n    \n\u2502\n \n0.00144064\n  \n\u2502\n\n \n\u2502\n \n996\n      \n\u2502\n \n996\n    \n\u2502\n \n0.0008423\n   \n\u2502\n\n \n\u2502\n \n997\n      \n\u2502\n \n997\n    \n\u2502\n \n0.00114039\n  \n\u2502\n\n \n\u2502\n \n998\n      \n\u2502\n \n998\n    \n\u2502\n \n0.00172091\n  \n\u2502\n\n \n\u2502\n \n999\n      \n\u2502\n \n999\n    \n\u2502\n \n0.00131404\n  \n\u2502\n\n \n\u2502\n \n1000\n     \n\u2502\n \n1000\n   \n\u2502\n \n0.00128859\n  \n\u2502\n\n\n\njuila\n \n# Display the edge table for edges where a shorter distance was found\n\n       \nEdgeDescriptor\n(@\nquery\n(\ng\n \n|\n \nfilter\n(\ne\n.\ndist\n \n!=\n \ne\n.\nshortest_distance\n)))\n\n \n\u2502\n \nIndex\n \n\u2502\n \nSource\n \n\u2502\n \nTarget\n \n\u2502\n \nweight\n   \n\u2502\n \ndist\n \n\u2502\n \nshortest_distance\n \n\u2502\n\n \n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\n \n\u2502\n \n1\n     \n\u2502\n \n1\n      \n\u2502\n \n339\n    \n\u2502\n \n0.544382\n \n\u2502\n \n8\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n2\n     \n\u2502\n \n1\n      \n\u2502\n \n667\n    \n\u2502\n \n0.983177\n \n\u2502\n \n8\n    \n\u2502\n \n7\n                 \n\u2502\n\n \n\u2502\n \n3\n     \n\u2502\n \n1\n      \n\u2502\n \n701\n    \n\u2502\n \n0.510004\n \n\u2502\n \n7\n    \n\u2502\n \n6\n                 \n\u2502\n\n \n\u2502\n \n4\n     \n\u2502\n \n1\n      \n\u2502\n \n744\n    \n\u2502\n \n0.678528\n \n\u2502\n \n10\n   \n\u2502\n \n3\n                 \n\u2502\n\n \n\u2502\n \n5\n     \n\u2502\n \n1\n      \n\u2502\n \n772\n    \n\u2502\n \n0.89435\n  \n\u2502\n \n10\n   \n\u2502\n \n8\n                 \n\u2502\n\n \n\u2502\n \n6\n     \n\u2502\n \n2\n      \n\u2502\n \n98\n     \n\u2502\n \n0.999188\n \n\u2502\n \n9\n    \n\u2502\n \n8\n                 \n\u2502\n\n \n\u2502\n \n7\n     \n\u2502\n \n2\n      \n\u2502\n \n237\n    \n\u2502\n \n0.578166\n \n\u2502\n \n10\n   \n\u2502\n \n7\n                 \n\u2502\n\n \n\u2502\n \n8\n     \n\u2502\n \n2\n      \n\u2502\n \n301\n    \n\u2502\n \n0.560192\n \n\u2502\n \n9\n    \n\u2502\n \n6\n                 \n\u2502\n\n \n\u2502\n \n9\n     \n\u2502\n \n2\n      \n\u2502\n \n476\n    \n\u2502\n \n0.602794\n \n\u2502\n \n8\n    \n\u2502\n \n7\n                 \n\u2502\n\n \n\u2502\n \n10\n    \n\u2502\n \n2\n      \n\u2502\n \n525\n    \n\u2502\n \n0.973554\n \n\u2502\n \n9\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n11\n    \n\u2502\n \n2\n      \n\u2502\n \n736\n    \n\u2502\n \n0.828569\n \n\u2502\n \n8\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n12\n    \n\u2502\n \n2\n      \n\u2502\n \n877\n    \n\u2502\n \n0.620037\n \n\u2502\n \n8\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u22ee\n\n \n\u2502\n \n10367\n \n\u2502\n \n998\n    \n\u2502\n \n840\n    \n\u2502\n \n0.941186\n \n\u2502\n \n8\n    \n\u2502\n \n4\n                 \n\u2502\n\n \n\u2502\n \n10368\n \n\u2502\n \n999\n    \n\u2502\n \n78\n     \n\u2502\n \n0.665393\n \n\u2502\n \n5\n    \n\u2502\n \n3\n                 \n\u2502\n\n \n\u2502\n \n10369\n \n\u2502\n \n999\n    \n\u2502\n \n281\n    \n\u2502\n \n0.878904\n \n\u2502\n \n9\n    \n\u2502\n \n6\n                 \n\u2502\n\n \n\u2502\n \n10370\n \n\u2502\n \n999\n    \n\u2502\n \n350\n    \n\u2502\n \n0.628088\n \n\u2502\n \n6\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n10371\n \n\u2502\n \n999\n    \n\u2502\n \n528\n    \n\u2502\n \n0.699302\n \n\u2502\n \n10\n   \n\u2502\n \n6\n                 \n\u2502\n\n \n\u2502\n \n10372\n \n\u2502\n \n999\n    \n\u2502\n \n653\n    \n\u2502\n \n0.860554\n \n\u2502\n \n9\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n10373\n \n\u2502\n \n999\n    \n\u2502\n \n715\n    \n\u2502\n \n0.74898\n  \n\u2502\n \n9\n    \n\u2502\n \n7\n                 \n\u2502\n\n \n\u2502\n \n10374\n \n\u2502\n \n999\n    \n\u2502\n \n726\n    \n\u2502\n \n0.772087\n \n\u2502\n \n9\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n10375\n \n\u2502\n \n999\n    \n\u2502\n \n862\n    \n\u2502\n \n0.852327\n \n\u2502\n \n7\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n10376\n \n\u2502\n \n999\n    \n\u2502\n \n947\n    \n\u2502\n \n0.907081\n \n\u2502\n \n7\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n10377\n \n\u2502\n \n1000\n   \n\u2502\n \n370\n    \n\u2502\n \n0.916611\n \n\u2502\n \n9\n    \n\u2502\n \n6\n                 \n\u2502\n\n \n\u2502\n \n10378\n \n\u2502\n \n1000\n   \n\u2502\n \n375\n    \n\u2502\n \n0.902912\n \n\u2502\n \n8\n    \n\u2502\n \n4\n                 \n\u2502\n\n \n\u2502\n \n10379\n \n\u2502\n \n1000\n   \n\u2502\n \n390\n    \n\u2502\n \n0.523391\n \n\u2502\n \n7\n    \n\u2502\n \n5\n                 \n\u2502\n\n \n\u2502\n \n10380\n \n\u2502\n \n1000\n   \n\u2502\n \n421\n    \n\u2502\n \n0.673928\n \n\u2502\n \n9\n    \n\u2502\n \n5\n                 \n\u2502\n\n\n\n\n\n\nDetailed Documentation:\n\n\n#\n\n\nGraft.export_adjacency\n \n \nFunction\n.\n\n\nThis method provides compatibilty with LightGraphs.jl, by returning the graph's adjacency matrix.\n\n\nimport\n \nLightGraphs\n\n\ng\n \n=\n \nGraph\n(\n10\n^\n5\n,\n \n10\n^\n6\n)\n\n\n\n# Construct a LightGraphs DiGraph from the exported adjacency matrix\n\n\nLightGraphs\n.\nDiGraph\n(\nexport_adjacency\n(\ng\n))\n\n\n\n\n\n\nsource\n\n\n#\n\n\nGraft.export_vertex_property\n \n \nFunction\n.\n\n\nThis method provides compatibilty with LightGraphs.jl, by returning an array containing all values for a vertex property\n\n\nsource\n\n\n#\n\n\nGraft.export_edge_property\n \n \nFunction\n.\n\n\nThis method provides compatibilty with LightGraphs.jl, by returning a SparseMatrixCSC containing all values for an edge property\n\n\nsource", 
            "title": "Export"
        }, 
        {
            "location": "/export/#export-api", 
            "text": "Graft supports the export of adjacency matrices and metadata, for use in Graph libraries such as LightGraphs. The example below shows how a workflow involving LightGraphs algorithms may look like.  using   Graft  import   LightGraphs  g   =   Graph ( 10 ^ 3 ,   5   *   10 ^ 4 );  setlabel! ( g ,   map ( string ,   1   :   10 ^ 3 ));  julia   # Set edge properties \n        seteprop! ( g ,   :,   rand ( ne ( g )),   : weight );  julia   seteprop! ( g ,   :,   rand ( 1   :   10 ,   ne ( g )),   : dist );  julia   # Discard low weight edges \n        g   =   @ query ( g   |   filter ( e . weight   =   0.5 ))  Graph ( 1000   vertices ,   24939   edges ,   Symbol []   vertex   properties ,   Symbol [: weight ,: dist ]   edge   properties )  julia   # Export g s adjacency matrix \n        M   =   export_adjacency ( g ) \n  1000 \u00d71000   sparse   matrix   with   24939   Int64   nonzero   entries : \n     [ 33    ,      1 ]    =    1 \n     [ 63    ,      1 ]    =    2 \n     [ 131   ,      1 ]    =    3 \n     [ 161   ,      1 ]    =    4 \n     [ 224   ,      1 ]    =    5 \n     [ 339   ,      1 ]    =    6 \n     [ 380   ,      1 ]    =    7 \n     [ 491   ,      1 ]    =    8 \n     [ 667   ,      1 ]    =    9 \n     \u22ee \n     [ 524   ,   1000 ]    =    24931 \n     [ 615   ,   1000 ]    =    24932 \n     [ 624   ,   1000 ]    =    24933 \n     [ 628   ,   1000 ]    =    24934 \n     [ 638   ,   1000 ]    =    24935 \n     [ 846   ,   1000 ]    =    24936 \n     [ 870   ,   1000 ]    =    24937 \n     [ 871   ,   1000 ]    =    24938 \n     [ 956   ,   1000 ]    =    24939  julia   # Export g s edge dists \n        D   =   export_edge_property ( g ,   : dist ) \n  1000 \u00d71000   sparse   matrix   with   24939   Int64   nonzero   entries : \n     [ 33    ,      1 ]    =    4 \n     [ 63    ,      1 ]    =    4 \n     [ 131   ,      1 ]    =    4 \n     [ 161   ,      1 ]    =    4 \n     [ 224   ,      1 ]    =    4 \n     [ 339   ,      1 ]    =    8 \n     [ 380   ,      1 ]    =    6 \n     [ 491   ,      1 ]    =    1 \n     [ 667   ,      1 ]    =    8 \n     \u22ee \n     [ 615   ,   1000 ]    =    5 \n     [ 624   ,   1000 ]    =    3 \n     [ 628   ,   1000 ]    =    5 \n     [ 638   ,   1000 ]    =    2 \n     [ 846   ,   1000 ]    =    1 \n     [ 870   ,   1000 ]    =    7 \n     [ 871   ,   1000 ]    =    5 \n     [ 956   ,   1000 ]    =    4  julia   # Construct a LightGraphs graph \n        lg   =   LightGraphs . DiGraph ( M )  { 1000 ,   24939 }   directed   graph  julia   # Calculate all pair shortest paths \n        sdists   =   LightGraphs . floyd_warshall_shortest_paths ( lg ,   D ) . dists  1000 \u00d71000   Array { Int64 , 2 }:  5    5    4    5    6    6    6    6    6    6    6   \u2026   4    6    4    6    5    6    4    5    7    5    3    6  6    7    7    6    6    7    7    4    6    4    6     6    7    2    6    7    6    6    6    7    6    5    6  7    6    7    5    8    5    6    7    6    7    5     5    7    6    6    7    7    8    5    7    6    6    7  5    7    5    4    7    6    6    7    6    6    5   \u2026   6    6    3    6    5    4    7    6    6    7    5    5  4    7    7    3    7    5    7    6    2    4    6     4    6    5    6    5    7    7    7    6    6    6    6  7    7    7    5    7    6    7    6    5    4    5     4    7    7    6    6    8    6    6    6    5    6    5  7    6    7    6    8    5    7    7    8    8    6   \u2026   7    7    7    6    8    8    9    7    9    7    7    5  7    4    7    5    4    5    4    6    6    8    6     4    7    6    5    7    6    7    6    6    5    7    5  7    6    6    7    4    5    5    6    7    9    6     7    4    6    6    7    7    6    6    7    7    5    7  7    5    7    5    6    5    7    5    6    5    6   \u2026   5    6    5    4    4    6    7    4    7    5    5    3  5    3    6    5    7    5    6    4    6    7    6     5    6    4    6    5    5    4    5    6    7    5    6  4    5    6    5    5    5    6    5    3    4    6     5    6    3    7    6    7    6    6    5    4    5    6  \u22ee       \u22ee        \u22ee       \u22ee        \u22ee        \u22f1      \u22ee       \u22ee        \u22ee       \u22ee       \u22ee        \u22ee  8    8    5    6    7    6    6    3    6    4    7     7    6    6    7    4    5    3    8    3    5    6    4  7    7    6    7    4    3    6    5    7    5    5     6    5    7    5    4    6    5    7    4    6    7    6  6    7    7    7    5    7    6    3    5    7    7   \u2026    7    5    6    6    5    7    5    6    5    6    5    5  6    6    7    7    6    3    5    6    5    7    4     7    7    5    5    3    6    5    7    7    6    7    4  8    7    5    5    4    7    7    6    6    7    8     8    8    5    5    7    5    8    6    7    4    7    8  6    6    6    7    5    6    5    6    4    6    5   \u2026   6    7    7    6    3    8    5    8    6    5    7    6  7    6    6    5    5    5    6    6    7    7    5     6    7    6    5    3    5    5    8    5    5    6    6  6    7    5    6    7    6    6    6    7    6    7     3    4    8    5    6    6    4    5    7    5    4    5  9    9    7    9    7    8    7    6    9    9    7   \u2026   9    6    9    9    8    8    6    9    7    7    0    7  8    8    8    7    7    8    6    7    8    7    8     8    8    4    6    8    7    7    9    8    8    9    8  6    5    6    6    3    5    7    6    7    6    6     7    7    7    5    4    7    7    7    6    7    4    8  7    6    6    4    6    6    4    5    7    7    6   \u2026   7    6    5    6    3    6    5    5    6    5    8    6  julia   # Find the shortest distances for edge pairs \n        sdists   =   [ sdists [ e . second ,   e . first ]   for   e   in   edges ( g )];  julia   # Make the shortest distances an edge proeprty \n        seteprop! ( g ,   :,   sdists ,   : shortest_distance );  julia   # Calculate the graph s betweenness centrality \n        centrality   =   LightGraphs . betweenness_centrality ( lg );  julia   # Make the centrality calculate above a vertex property \n        setvprop! ( g ,   :,   centrality ,   : centrality )  julia   # Display the vertex table \n        VertexDescriptor ( g ) \n  \u2502   VertexID   \u2502   Labels   \u2502   centrality    \u2502 \n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \n  \u2502   1          \u2502   1        \u2502   0.00100559    \u2502 \n  \u2502   2          \u2502   2        \u2502   0.00115523    \u2502 \n  \u2502   3          \u2502   3        \u2502   0.00139773    \u2502 \n  \u2502   4          \u2502   4        \u2502   0.00161647    \u2502 \n  \u2502   5          \u2502   5        \u2502   0.00184465    \u2502 \n  \u2502   6          \u2502   6        \u2502   0.00152136    \u2502 \n  \u2502   7          \u2502   7        \u2502   0.00113189    \u2502 \n  \u2502   8          \u2502   8        \u2502   0.00147083    \u2502 \n  \u22ee \n  \u2502   990        \u2502   990      \u2502   0.00233637    \u2502 \n  \u2502   991        \u2502   991      \u2502   0.00101592    \u2502 \n  \u2502   992        \u2502   992      \u2502   0.00152453    \u2502 \n  \u2502   993        \u2502   993      \u2502   0.00124928    \u2502 \n  \u2502   994        \u2502   994      \u2502   0.000931563   \u2502 \n  \u2502   995        \u2502   995      \u2502   0.00144064    \u2502 \n  \u2502   996        \u2502   996      \u2502   0.0008423     \u2502 \n  \u2502   997        \u2502   997      \u2502   0.00114039    \u2502 \n  \u2502   998        \u2502   998      \u2502   0.00172091    \u2502 \n  \u2502   999        \u2502   999      \u2502   0.00131404    \u2502 \n  \u2502   1000       \u2502   1000     \u2502   0.00128859    \u2502  juila   # Display the edge table for edges where a shorter distance was found \n        EdgeDescriptor (@ query ( g   |   filter ( e . dist   !=   e . shortest_distance ))) \n  \u2502   Index   \u2502   Source   \u2502   Target   \u2502   weight     \u2502   dist   \u2502   shortest_distance   \u2502 \n  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \n  \u2502   1       \u2502   1        \u2502   339      \u2502   0.544382   \u2502   8      \u2502   5                   \u2502 \n  \u2502   2       \u2502   1        \u2502   667      \u2502   0.983177   \u2502   8      \u2502   7                   \u2502 \n  \u2502   3       \u2502   1        \u2502   701      \u2502   0.510004   \u2502   7      \u2502   6                   \u2502 \n  \u2502   4       \u2502   1        \u2502   744      \u2502   0.678528   \u2502   10     \u2502   3                   \u2502 \n  \u2502   5       \u2502   1        \u2502   772      \u2502   0.89435    \u2502   10     \u2502   8                   \u2502 \n  \u2502   6       \u2502   2        \u2502   98       \u2502   0.999188   \u2502   9      \u2502   8                   \u2502 \n  \u2502   7       \u2502   2        \u2502   237      \u2502   0.578166   \u2502   10     \u2502   7                   \u2502 \n  \u2502   8       \u2502   2        \u2502   301      \u2502   0.560192   \u2502   9      \u2502   6                   \u2502 \n  \u2502   9       \u2502   2        \u2502   476      \u2502   0.602794   \u2502   8      \u2502   7                   \u2502 \n  \u2502   10      \u2502   2        \u2502   525      \u2502   0.973554   \u2502   9      \u2502   5                   \u2502 \n  \u2502   11      \u2502   2        \u2502   736      \u2502   0.828569   \u2502   8      \u2502   5                   \u2502 \n  \u2502   12      \u2502   2        \u2502   877      \u2502   0.620037   \u2502   8      \u2502   5                   \u2502 \n  \u22ee \n  \u2502   10367   \u2502   998      \u2502   840      \u2502   0.941186   \u2502   8      \u2502   4                   \u2502 \n  \u2502   10368   \u2502   999      \u2502   78       \u2502   0.665393   \u2502   5      \u2502   3                   \u2502 \n  \u2502   10369   \u2502   999      \u2502   281      \u2502   0.878904   \u2502   9      \u2502   6                   \u2502 \n  \u2502   10370   \u2502   999      \u2502   350      \u2502   0.628088   \u2502   6      \u2502   5                   \u2502 \n  \u2502   10371   \u2502   999      \u2502   528      \u2502   0.699302   \u2502   10     \u2502   6                   \u2502 \n  \u2502   10372   \u2502   999      \u2502   653      \u2502   0.860554   \u2502   9      \u2502   5                   \u2502 \n  \u2502   10373   \u2502   999      \u2502   715      \u2502   0.74898    \u2502   9      \u2502   7                   \u2502 \n  \u2502   10374   \u2502   999      \u2502   726      \u2502   0.772087   \u2502   9      \u2502   5                   \u2502 \n  \u2502   10375   \u2502   999      \u2502   862      \u2502   0.852327   \u2502   7      \u2502   5                   \u2502 \n  \u2502   10376   \u2502   999      \u2502   947      \u2502   0.907081   \u2502   7      \u2502   5                   \u2502 \n  \u2502   10377   \u2502   1000     \u2502   370      \u2502   0.916611   \u2502   9      \u2502   6                   \u2502 \n  \u2502   10378   \u2502   1000     \u2502   375      \u2502   0.902912   \u2502   8      \u2502   4                   \u2502 \n  \u2502   10379   \u2502   1000     \u2502   390      \u2502   0.523391   \u2502   7      \u2502   5                   \u2502 \n  \u2502   10380   \u2502   1000     \u2502   421      \u2502   0.673928   \u2502   9      \u2502   5                   \u2502   Detailed Documentation:  #  Graft.export_adjacency     Function .  This method provides compatibilty with LightGraphs.jl, by returning the graph's adjacency matrix.  import   LightGraphs  g   =   Graph ( 10 ^ 5 ,   10 ^ 6 )  # Construct a LightGraphs DiGraph from the exported adjacency matrix  LightGraphs . DiGraph ( export_adjacency ( g ))   source  #  Graft.export_vertex_property     Function .  This method provides compatibilty with LightGraphs.jl, by returning an array containing all values for a vertex property  source  #  Graft.export_edge_property     Function .  This method provides compatibilty with LightGraphs.jl, by returning a SparseMatrixCSC containing all values for an edge property  source", 
            "title": "Export API"
        }, 
        {
            "location": "/edgeiter/", 
            "text": "EdgeIteration\n\n\nGraft provides the \nEdgeIter\n type for fast, alloc-free edge iteration. This type simplifies the indexing and construction of sparse matrices.\n\n\nThe following example demonstrates the usage of \nEdgeIter\n:\n\n\njulia\n \nusing\n \nGraft\n\n\n\njulia\n \ng\n \n=\n \ncompletegraph\n(\n3\n)\n\n\nGraph\n(\n3\n \nvertices\n,\n \n6\n \nedges\n,\n \nSymbol\n[]\n \nvertex\n \nproperties\n,\n \nSymbol\n[]\n \nedge\n \nproperties\n)\n\n\n\njulia\n \n# Build an iterator for all edges in the graph\n\n       \neit\n \n=\n \nedges\n(\ng\n)\n\n\n6\n-\nelement\n \nGraft\n.\nEdgeIter\n:\n\n \n1\n=\n2\n\n \n1\n=\n3\n\n \n2\n=\n1\n\n \n2\n=\n3\n\n \n3\n=\n1\n\n \n3\n=\n2\n\n\n\njulia\n \n# Iterate through edges\n\n       \nfor\n \ne\n \nin\n \neit\n\n          \n# Do something here\n\n       \nend\n\n\n\njulia\n \n# Use in list comprehensions\n\n       \n[\ne\n \nfor\n \ne\n \nin\n \neit\n]\n\n\n6\n-\nelement\n \nArray\n{\nPair\n{\nInt64\n,\nInt64\n},\n1\n}:\n\n \n1\n=\n2\n\n \n1\n=\n3\n\n \n2\n=\n1\n\n \n2\n=\n3\n\n \n3\n=\n1\n\n \n3\n=\n2\n\n\n\njulia\n \n# Get the third edge in the graph\n\n       \neit\n[\n3\n]\n\n\n2\n=\n1\n\n\n\njulia\n \n# Get a subset of the edges in the graph (returns a new iterator)\n\n       \neit\n[\n1\n:\n3\n]\n\n\n3\n-\nelement\n \nGraft\n.\nEdgeIter\n:\n\n \n1\n=\n2\n\n \n1\n=\n3\n\n \n2\n=\n1\n\n\n\njulia\n \n# Concatenate two iterators\n\n       \nvcat\n(\neit\n[\n4\n:\n6\n],\n \neit\n[\n1\n:\n3\n])\n\n\n6\n-\nelement\n \nGraft\n.\nEdgeIter\n:\n\n \n2\n=\n3\n\n \n3\n=\n1\n\n \n3\n=\n2\n\n \n1\n=\n2\n\n \n1\n=\n3\n\n \n2\n=\n1\n\n\n\njulia\n \n# Edge iterator implements the AbstractVector{Pair{Int,Int}} interface\n\n       \nsort\n(\nans\n)\n\n\n6\n-\nelement\n \nArray\n{\nPair\n{\nInt64\n,\nInt64\n},\n1\n}:\n\n \n1\n=\n2\n\n \n1\n=\n3\n\n \n2\n=\n1\n\n \n2\n=\n3\n\n \n3\n=\n1\n\n \n3\n=\n2\n\n\n\n\n\n\nDetailed documentation:\n\n\n#\n\n\nGraft.EdgeIter\n \n \nType\n.\n\n\nAn abstraction for alloc-free, fast edge iteration\n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGet the ith edge in the iterator \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGet a new iterator containing a subset of the edges \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGet a copy of the iterator \n\n\nsource\n\n\n#\n\n\nBase.vcat\n \n \nMethod\n.\n\n\nConcatenate two iterators \n\n\nsource", 
            "title": "Edge Iteration"
        }, 
        {
            "location": "/edgeiter/#edgeiteration", 
            "text": "Graft provides the  EdgeIter  type for fast, alloc-free edge iteration. This type simplifies the indexing and construction of sparse matrices.  The following example demonstrates the usage of  EdgeIter :  julia   using   Graft  julia   g   =   completegraph ( 3 )  Graph ( 3   vertices ,   6   edges ,   Symbol []   vertex   properties ,   Symbol []   edge   properties )  julia   # Build an iterator for all edges in the graph \n        eit   =   edges ( g )  6 - element   Graft . EdgeIter : \n  1 = 2 \n  1 = 3 \n  2 = 1 \n  2 = 3 \n  3 = 1 \n  3 = 2  julia   # Iterate through edges \n        for   e   in   eit \n           # Do something here \n        end  julia   # Use in list comprehensions \n        [ e   for   e   in   eit ]  6 - element   Array { Pair { Int64 , Int64 }, 1 }: \n  1 = 2 \n  1 = 3 \n  2 = 1 \n  2 = 3 \n  3 = 1 \n  3 = 2  julia   # Get the third edge in the graph \n        eit [ 3 ]  2 = 1  julia   # Get a subset of the edges in the graph (returns a new iterator) \n        eit [ 1 : 3 ]  3 - element   Graft . EdgeIter : \n  1 = 2 \n  1 = 3 \n  2 = 1  julia   # Concatenate two iterators \n        vcat ( eit [ 4 : 6 ],   eit [ 1 : 3 ])  6 - element   Graft . EdgeIter : \n  2 = 3 \n  3 = 1 \n  3 = 2 \n  1 = 2 \n  1 = 3 \n  2 = 1  julia   # Edge iterator implements the AbstractVector{Pair{Int,Int}} interface \n        sort ( ans )  6 - element   Array { Pair { Int64 , Int64 }, 1 }: \n  1 = 2 \n  1 = 3 \n  2 = 1 \n  2 = 3 \n  3 = 1 \n  3 = 2   Detailed documentation:  #  Graft.EdgeIter     Type .  An abstraction for alloc-free, fast edge iteration  source  #  Base.getindex     Method .  Get the ith edge in the iterator   source  #  Base.getindex     Method .  Get a new iterator containing a subset of the edges   source  #  Base.getindex     Method .  Get a copy of the iterator   source  #  Base.vcat     Method .  Concatenate two iterators   source", 
            "title": "EdgeIteration"
        }, 
        {
            "location": "/internal/", 
            "text": "Internal Documentation\n\n\n\n\nGraft.DictLM\n\n\nGraft.DictLM\n\n\nGraft.DictLM\n\n\nGraft.EdgeIter\n\n\nGraft.Graph\n\n\nGraft.Graph\n\n\nGraft.Graph\n\n\nGraft.Graph\n\n\nGraft.Graph\n\n\nGraft.IdentityLM\n\n\nGraft.LabelMap\n\n\nGraft.addedge!\n\n\nGraft.addvertex!\n\n\nGraft.bfs\n\n\nGraft.bfs_list\n\n\nGraft.bfs_subgraph\n\n\nGraft.bfs_tree\n\n\nGraft.completegraph\n\n\nGraft.completeindxs\n\n\nGraft.decode\n\n\nGraft.decode\n\n\nGraft.encode\n\n\nGraft.export_adjacency\n\n\nGraft.export_edge_property\n\n\nGraft.export_vertex_property\n\n\nGraft.fadj\n\n\nGraft.fadj!\n\n\nGraft.geteprop\n\n\nGraft.getvprop\n\n\nGraft.haseprop\n\n\nGraft.hasvprop\n\n\nGraft.hopgraph\n\n\nGraft.hoplist\n\n\nGraft.hoptree\n\n\nGraft.indegree\n\n\nGraft.listeprops\n\n\nGraft.listvprops\n\n\nGraft.loadgraph\n\n\nGraft.ne\n\n\nGraft.nv\n\n\nGraft.outdegree\n\n\nGraft.propgraph\n\n\nGraft.randgraph\n\n\nGraft.randindxs\n\n\nGraft.relabel!\n\n\nGraft.relabel!\n\n\nGraft.reorder!\n\n\nGraft.reorder!\n\n\nGraft.rmedge!\n\n\nGraft.rmvertex!\n\n\nGraft.rmvertex!\n\n\nGraft.seteprop!\n\n\nGraft.setlabel!\n\n\nGraft.setlabel!\n\n\nGraft.setvprop!\n\n\nGraft.storegraph\n\n\n\n\n#\n\n\nBase.SparseArrays.SparseMatrixCSC\n \n \nMethod\n.\n\n\nBuild an adjacency matrix from an edge iterator \n\n\nsource\n\n\n#\n\n\nGraft.DictLM\n \n \nType\n.\n\n\nThis label map is used when vertices are assigned meaningful labels. This type uses a dictionary to map labels onto vertex identifies, and a vector to map vertex identifiers onto labels.\n\n\nLabels can be of any user defined type.\n\n\nsource\n\n\n#\n\n\nGraft.DictLM\n \n \nMethod\n.\n\n\nConstruct a label map from a list of labels \n\n\nsource\n\n\n#\n\n\nGraft.DictLM\n \n \nMethod\n.\n\n\nConstruct a label map from the internally used vertex identifiers.\n\n\nsource\n\n\n#\n\n\nGraft.IdentityLM\n \n \nType\n.\n\n\nThe default label map, that indicates the absence of meaningful vertex labels. The usage of this type incurs zero overhead in label resolution.\n\n\nSince vertices are referred to by their internally used indices, the usage of this labelling scheme can be problematic when vertices are deleted.\n\n\nsource\n\n\n#\n\n\nGraft.LabelMap\n \n \nType\n.\n\n\nA type that forward maps labels into internally used vertex identifiers, and reverse maps vertex identifiers into labels.\n\n\nsource\n\n\n#\n\n\nBase.:+\n \n \nMethod\n.\n\n\nShorthand notation for adding multiple lablled vertices \n\n\nsource\n\n\n#\n\n\nBase.:+\n \n \nMethod\n.\n\n\nShorthand notation for adding a labelled vertex to the graph \n\n\nsource\n\n\n#\n\n\nBase.:-\n \n \nMethod\n.\n\n\nRemove a labelled vertex from the graph \n\n\nsource\n\n\n#\n\n\nBase.:-\n \n \nMethod\n.\n\n\nRemove a list of labelled vertices from the graph \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nShorcut to vertex v's out-neighbors in the graph \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nRetrieve the edge dataframe indices for a list of edges \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nRetrieve the edge dataframe indices for all edges in an edge iterator \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nRetrieve an edges' index in the ddge dataframe \n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nMerge two graphs into one. Currently this method assumes that both graphs have the same vertices, and doesn't combine their data, but does a union on their edges.\n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nShorthand notation for adding an edge between labelled vertices \n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nShorthand notation for adding multiple edges between labelled vertices \n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nChange the edge dataframe indices for a list of edges \n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nChange the edge dataframe indices for all edges in an iterator \n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nChange the edge dataframe indices for a list of edges \n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nChange the edge dataframe indices for all edges in an iterator \n\n\nsource\n\n\n#\n\n\nBase.setindex!\n \n \nMethod\n.\n\n\nChange an edge's index in the edge dataframe \n\n\nsource\n\n\n#\n\n\nBase.size\n \n \nMethod\n.\n\n\nReturn nv(g) x ne(g) \n\n\nsource\n\n\n#\n\n\nGraft.bfs\n \n \nFunction\n.\n\n\nStandard BFS implementation that returns a parent vector \n\n\nsource\n\n\n#\n\n\nGraft.bfs_list\n \n \nFunction\n.\n\n\nGet the list of vertices at a certain distance from the seed \n\n\nsource\n\n\n#\n\n\nGraft.bfs_subgraph\n \n \nFunction\n.\n\n\nReturns a BFS subgraph, containing explored vertices and all edges between them\n\n\nsource\n\n\n#\n\n\nGraft.bfs_tree\n \n \nFunction\n.\n\n\nReturns a BFS tree, containing explored vertices and only tree edges.\n\n\nsource\n\n\n#\n\n\nGraft.completeindxs\n \n \nMethod\n.\n\n\nSpawn a random sparse matrix denoting a complete graph without self loops. The returned matrix resembles a non-sparse matrix, so it'd be unwise to use this for a large number of vertices\n\n\nsource\n\n\n#\n\n\nGraft.randindxs\n \n \nMethod\n.\n\n\nSpawn a random sparse matrix, sort indices and remove self loops\n\n\nThe number of edges in the sparse matrix may not equal the input ne, and is more likely to be an approximate\n\n\nsource\n\n\n#\n\n\nGraft.reorder!\n \n \nMethod\n.\n\n\nReorder the edge dataframe to match the order of edges in the index table \n\n\nsource\n\n\n#\n\n\nGraft.reorder!\n \n \nMethod\n.\n\n\nSort the index entries \n\n\nsource", 
            "title": "Internal Docs"
        }, 
        {
            "location": "/internal/#internal-documentation", 
            "text": "Graft.DictLM  Graft.DictLM  Graft.DictLM  Graft.EdgeIter  Graft.Graph  Graft.Graph  Graft.Graph  Graft.Graph  Graft.Graph  Graft.IdentityLM  Graft.LabelMap  Graft.addedge!  Graft.addvertex!  Graft.bfs  Graft.bfs_list  Graft.bfs_subgraph  Graft.bfs_tree  Graft.completegraph  Graft.completeindxs  Graft.decode  Graft.decode  Graft.encode  Graft.export_adjacency  Graft.export_edge_property  Graft.export_vertex_property  Graft.fadj  Graft.fadj!  Graft.geteprop  Graft.getvprop  Graft.haseprop  Graft.hasvprop  Graft.hopgraph  Graft.hoplist  Graft.hoptree  Graft.indegree  Graft.listeprops  Graft.listvprops  Graft.loadgraph  Graft.ne  Graft.nv  Graft.outdegree  Graft.propgraph  Graft.randgraph  Graft.randindxs  Graft.relabel!  Graft.relabel!  Graft.reorder!  Graft.reorder!  Graft.rmedge!  Graft.rmvertex!  Graft.rmvertex!  Graft.seteprop!  Graft.setlabel!  Graft.setlabel!  Graft.setvprop!  Graft.storegraph   #  Base.SparseArrays.SparseMatrixCSC     Method .  Build an adjacency matrix from an edge iterator   source  #  Graft.DictLM     Type .  This label map is used when vertices are assigned meaningful labels. This type uses a dictionary to map labels onto vertex identifies, and a vector to map vertex identifiers onto labels.  Labels can be of any user defined type.  source  #  Graft.DictLM     Method .  Construct a label map from a list of labels   source  #  Graft.DictLM     Method .  Construct a label map from the internally used vertex identifiers.  source  #  Graft.IdentityLM     Type .  The default label map, that indicates the absence of meaningful vertex labels. The usage of this type incurs zero overhead in label resolution.  Since vertices are referred to by their internally used indices, the usage of this labelling scheme can be problematic when vertices are deleted.  source  #  Graft.LabelMap     Type .  A type that forward maps labels into internally used vertex identifiers, and reverse maps vertex identifiers into labels.  source  #  Base.:+     Method .  Shorthand notation for adding multiple lablled vertices   source  #  Base.:+     Method .  Shorthand notation for adding a labelled vertex to the graph   source  #  Base.:-     Method .  Remove a labelled vertex from the graph   source  #  Base.:-     Method .  Remove a list of labelled vertices from the graph   source  #  Base.getindex     Method .  Shorcut to vertex v's out-neighbors in the graph   source  #  Base.getindex     Method .  Retrieve the edge dataframe indices for a list of edges   source  #  Base.getindex     Method .  Retrieve the edge dataframe indices for all edges in an edge iterator   source  #  Base.getindex     Method .  Retrieve an edges' index in the ddge dataframe   source  #  Base.merge     Method .  Merge two graphs into one. Currently this method assumes that both graphs have the same vertices, and doesn't combine their data, but does a union on their edges.  source  #  Base.setindex!     Method .  Shorthand notation for adding an edge between labelled vertices   source  #  Base.setindex!     Method .  Shorthand notation for adding multiple edges between labelled vertices   source  #  Base.setindex!     Method .  Change the edge dataframe indices for a list of edges   source  #  Base.setindex!     Method .  Change the edge dataframe indices for all edges in an iterator   source  #  Base.setindex!     Method .  Change the edge dataframe indices for a list of edges   source  #  Base.setindex!     Method .  Change the edge dataframe indices for all edges in an iterator   source  #  Base.setindex!     Method .  Change an edge's index in the edge dataframe   source  #  Base.size     Method .  Return nv(g) x ne(g)   source  #  Graft.bfs     Function .  Standard BFS implementation that returns a parent vector   source  #  Graft.bfs_list     Function .  Get the list of vertices at a certain distance from the seed   source  #  Graft.bfs_subgraph     Function .  Returns a BFS subgraph, containing explored vertices and all edges between them  source  #  Graft.bfs_tree     Function .  Returns a BFS tree, containing explored vertices and only tree edges.  source  #  Graft.completeindxs     Method .  Spawn a random sparse matrix denoting a complete graph without self loops. The returned matrix resembles a non-sparse matrix, so it'd be unwise to use this for a large number of vertices  source  #  Graft.randindxs     Method .  Spawn a random sparse matrix, sort indices and remove self loops  The number of edges in the sparse matrix may not equal the input ne, and is more likely to be an approximate  source  #  Graft.reorder!     Method .  Reorder the edge dataframe to match the order of edges in the index table   source  #  Graft.reorder!     Method .  Sort the index entries   source", 
            "title": "Internal Documentation"
        }
    ]
}