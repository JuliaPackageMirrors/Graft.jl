{
    "docs": [
        {
            "location": "/", 
            "text": "Graft Documentation\n\n\n\n\nGraft Documentation\n\n\nThe Graph datastructure\n\n\nEdgeIteration\n\n\nMetadata\n\n\nQueries\n\n\n\n\n\n\n\n\n\n\nThe Graph datastructure\n\n\nThe Graph datatype is the core datastructure used in Graft.jl. The Graph datatype has the following fields: 1. nv     : The number of vertices in the graph. 2. ne     : The number of edges int he graph. 3. indxs  : The adjacency matrix for the graph. The SparseMatrixCSC type is used here, both             as an adjacency matrix and as an index table, that maps edges onto their entries in the             edge dataframe. 4. vdata  : A dataframe used to store vertex data. This dataframe is indexed by the internally used             vertex identifiers. 5. edata  : An edge dataframe used to store edge data. This dataframe is indexed by indxs datastructure. 6. lmap   : A label map that maps externally used labels onto the internally used vertex identifiers and vice versa.\n\n\n\n\nAccessors\n\n\n#\n\n\nGraft.nv\n \n \nFunction\n.\n\n\nThe number of vertices in the adjacency matrix \n\n\nsource\n\n\nThe number of vertices in the graph \n\n\nsource\n\n\n#\n\n\nGraft.ne\n \n \nFunction\n.\n\n\nThe number of edges in the adjacency matrix \n\n\nsource\n\n\nThe number of edges in the graph \n\n\nsource\n\n\n#\n\n\nGraft.indxs\n \n \nFunction\n.\n\n\nRetrieve the adjacency matrix / edge index table \n\n\nsource\n\n\n#\n\n\nGraft.vdata\n \n \nFunction\n.\n\n\nRetrieve the vertex dataframe \n\n\nsource\n\n\n#\n\n\nGraft.edata\n \n \nFunction\n.\n\n\nRetrieve the edge dataframe \n\n\nsource\n\n\n#\n\n\nGraft.lmap\n \n \nFunction\n.\n\n\nRetrieve the label map \n\n\nsource\n\n\n\n\nConstruction\n\n\nThe following methods can be used to construct unlabelled graphs:\n\n\nemptygraph\nrandgraph\ncompletegraph\n\n\n\n\n\nLabelled graphs can be build using the constructors:\n\n\nGraph(::Int, ::Vector)\nGraph(::Int, ::Vector, ::Int)\n\n\n\n\n\n\n\nCombinatorial stuff\n\n\nBasic methods on graph structure:\n\n\n#\n\n\nGraft.vertices\n \n \nFunction\n.\n\n\nThe list of the vertices in the graph \n\n\nsource\n\n\n#\n\n\nGraft.edges\n \n \nFunction\n.\n\n\nReturns an edge iterator containing all edges in the graph \n\n\nsource\n\n\n#\n\n\nGraft.hasvertex\n \n \nFunction\n.\n\n\nCheck if the vertex(s) exists \n\n\nsource\n\n\n#\n\n\nGraft.hasedge\n \n \nFunction\n.\n\n\nCheck if the edge(s) exists \n\n\nsource\n\n\nAdjacency queries:\n\n\n#\n\n\nGraft.fadj\n \n \nFunction\n.\n\n\nRetrieve a list of vertices connected to vertex v.\n\n\nThis method spwans a new array, so is slow and malloc prone.\n\n\nsource\n\n\nVertex v's out-neighbors in the graph \n\n\nsource\n\n\n#\n\n\nGraft.fadj!\n \n \nFunction\n.\n\n\nRetrieve a list of vertices connect to vertex v.\n\n\nThis method copies the adjacencies onto the input array, and is comparitively faster, and causes no mallocs.\n\n\nsource\n\n\nRetrieve a list of vertices connect to vertex v.\n\n\nThis method copies the adjacencies onto the input array, and is comparitively faster, and causes no mallocs.\n\n\nsource\n\n\n#\n\n\nGraft.outdegree\n \n \nFunction\n.\n\n\nCompute the outdegree of a vertex \n\n\nsource\n\n\nVertex v's outdegree in the graph \n\n\nsource\n\n\n#\n\n\nGraft.indegree\n \n \nFunction\n.\n\n\nCompute the indegree of a vertex. This method is slow since reverse adjacencies are not stored\n\n\nsource\n\n\nVertex v's indegree in the graph \n\n\nsource\n\n\n\n\nGraph mutations\n\n\nGraphs can be modified using the following methods:\n\n\naddvertex!(::Graph)\naddvertex!(::Graph, ::Any)\naddedge!(::Graph, ::Pair{Int,Int})\nrmvertex!(::Graph, ::Int)\nrmvertex!(::Graph, ::AbstractVector{Int})\nrmedge!(::Graph, ::Pair{Int,Int})\n\n\n\n\n\n\n\nLabelling\n\n\nNew labels can be added or removed through the following methods:\n\n\n#\n\n\nGraft.setlabel!\n \n \nMethod\n.\n\n\nSet labels for all vertices in the graph \n\n\nsource\n\n\n#\n\n\nGraft.setlabel!\n \n \nMethod\n.\n\n\nUse a vertex property as the vertex label \n\n\nsource\n\n\n#\n\n\nGraft.setlabel!\n \n \nMethod\n.\n\n\nRemove all vertex labels \n\n\nsource\n\n\nLabels can be modified through the following methods:\n\n\n#\n\n\nGraft.relabel!\n \n \nMethod\n.\n\n\nRelabel a single vertex in the graph \n\n\nsource\n\n\n#\n\n\nGraft.relabel!\n \n \nMethod\n.\n\n\nRelabel a list of vertices in the graph \n\n\nsource\n\n\n\n\nEdgeIteration\n\n\nThe EdgeIter type provides alloc-free and fast edge iteration.\n\n\n\n\nConstruction\n\n\n#\n\n\nGraft.edges\n \n \nMethod\n.\n\n\nReturns an edge iterator containing all edges in the graph \n\n\nsource\n\n\n\n\nGetindex\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGet the ith edge in the iterator \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGet a new iterator containing a subset of the edges \n\n\nsource\n\n\n#\n\n\nBase.getindex\n \n \nMethod\n.\n\n\nGet a copy of the iterator \n\n\nsource\n\n\n\n\nConcatenation\n\n\n#\n\n\nBase.vcat\n \n \nMethod\n.\n\n\nConcatenate two iterators \n\n\nsource\n\n\n\n\nUsage\n\n\nusing\n \nGraft\n\n\n\ng\n \n=\n \ncompletegraph\n(\n3\n)\n\n\n\n# Construct Iterator\n\n\neit\n \n=\n \nedges\n(\ng\n)\n\n\n\n# Iterate through edges\n\n\nfor\n \ne\n \nin\n \neit\n\n   \n# Do something here\n\n\nend\n\n\n\n# In list comprehensions\n\n\n[\ne\n \nfor\n \ne\n \nin\n \neit\n]\n\n\n\n\n\n\n6-element Array{Pair{Int64,Int64},1}:\n 1=\n2\n 1=\n3\n 2=\n1\n 2=\n3\n 3=\n1\n 3=\n2\n\n\n\n\n\n\n\nMetadata\n\n\n\n\nSetting vertex metadata\n\n\n#\n\n\nGraft.setvprop!\n \n \nFunction\n.\n\n\nSet vertex properties.\n\n\nsetvprop!(g::Graph, v::VertexID, val(s), vprop::Symbol) -\n Set a property for v\n\n\nsource\n\n\nsetvprop!(g::Graph, vs::VertexList, val(s), vprop::Symbol) -\n Set a property for v in vs \n\n\nsource\n\n\nsetvprop!(g::Graph, ::Colon, val(s), vprop::Symbol) -\n Set a property for all vertices in g \n\n\nsource\n\n\n\n\nRetrieving vertex metadata\n\n\n#\n\n\nGraft.getvprop\n \n \nFunction\n.\n\n\nRetrieve vertex properties.\n\n\ngetvprop(g::Graph, v::VertexID, vprop::Symbol) -\n Fetch the value of a property for vertex v\n\n\nsource\n\n\ngetvprop(g::Graph, vs::VertexList, vprop::Symbol) -\n Fetch the value of a property for v in vs \n\n\nsource\n\n\ngetvprop(g::Graph, ::Colon, vprop::Symbol) -\n Fetch the value of a property for all verices \n\n\nsource\n\n\n\n\nSetting edge metadata\n\n\n#\n\n\nGraft.seteprop!\n \n \nFunction\n.\n\n\nSet edge properties.\n\n\nseteprop!(g::Graph, e::EdgeID, val, eprop::Symbol) -\n Set a property for an edge e\n\n\nsource\n\n\nseteprop!(g::Graph, es::EdgeList, val(s), eprop::Symbol) -\n Set a property for e in es \n\n\nsource\n\n\nseteprop!(g::Graph, ::Colon, val(s), eprop::Symbol) \n\n\nsource\n\n\n\n\nRetrieving edge metadata\n\n\n#\n\n\nGraft.geteprop\n \n \nFunction\n.\n\n\nRetrieve edge properties.\n\n\ngeteprop(g::Graph, e::EdgeID, eprop::Symbol) -\n Fetch the value of a property for edge e\n\n\nsource\n\n\ngeteprop(g::Graph, es::EdgeList, eprop::Symbol) -\n Fetch the value of a property for edge e in es \n\n\nsource\n\n\ngeteprop(g::Graph, ::Colon, eprop::Symbol) -\n Fetch the value of a property for all edges \n\n\nsource\n\n\n\n\nQueries\n\n\nThe query macro is used to execute graph queries in a pipelined manner. The pipelining syntax is borrowed from jplyer, though I hope to use jplyer directly at some point, for lazy execution.\n\n\nThe main functionalities provided by the query macro are:\n\n\n\n\neachvertex:\n\n\nThis abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.\n\n\nFor example, \n@query g |\n eachvertex(v.p1 + v.p2 * v.p3)\n executes the expression \nv.p1 + v.p2 * v.p3\n on every vertex in the result from the previous pipeline stage. Here, \nv.p1\n denotes the value of property \np1\n for every vertex.\n\n\n\n\neachedge:\n\n\nThis abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.\n\n\nFor example, \n@query g |\n eachedge(e.p1 + s.p1 + t.p1)\n executes the expression \ne.p1 + s.p1 + t.p1\n on every edge in the graph. Here, 'e.p1' denotes the value of property \np1\n for every edge in the graph. Since each edge has a source vertex \ns\n and a target vertex \nt\n, the properties of these vertices can be used in the expression as shown by \ns.p1\n and \nt.p1\n.\n\n\n\n\nfilter\n\n\nThis abstraction is used to compute a subgraph of the input from the previous pipeline stage, on the given conditions.\n\n\nFor example, \n@query g |\n filter(v.p1 \n 5, v.p1 \n v.p2, e.p1 \n 5)\n uses the three filter conditions provided to compute a subgraph. Currently only binary comparisons are supported, so comparisons like 1 \n v.p1 \n v.p2 will not work. Instead you can supply multiple conditions as separate arguments.\n\n\n\n\nselect\n\n\nThis abstraction is used to compute a subgraph of the input from the previous pipeline state, for a subset of vertex and or edge properties.\n\n\nFor example, \n@query g |\n select(v.p1, v.p3, e.p1)\n preserves only vertex properties \np1\n,\np2\n and edge property \np1\n.\n\n\n\n\nExamples\n\n\nThe abstractions can be chained together using the pipe notation, so that the output of one stage becomes the input to the next.\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Run a filter using vertex properties\n\n\n@\nquery\n \ng\n \n|\n \nfilter\n(\n0.5\n \n=\n \nv\n.\np1\n,\n \nv\n.\np1\n \n \nv\n.\np2\n)\n\n\n\n\n\n\nGraph(1 vertices, 0 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)\n\n\n\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Run a filter using source and target properties\n\n\n@\nquery\n \ng\n \n|\n \nfilter\n(\ns\n.\np1\n \n \nt\n.\np2\n)\n\n\n\n\n\n\nGraph(10 vertices, 61 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)\n\n\n\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Run filter using edge properties\n\n\n@\nquery\n \ng\n \n|\n \nfilter\n(\ne\n.\np1\n \n \n0.7\n)\n\n\n\n\n\n\nGraph(10 vertices, 57 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)\n\n\n\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Chain filter expressions\n\n\n@\nquery\n \ng\n \n|\n \nfilter\n(\nv\n.\np1\n \n \nv\n.\np2\n)\n \n|\n \nfilter\n(\ne\n.\np1\n \n \ne\n.\np1\n)\n\n\n\n\n\n\nGraph(5 vertices, 0 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)\n\n\n\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Select properties\n\n\n@\nquery\n \ng\n \n|\n \nfilter\n(\nv\n.\np1\n \n \nv\n.\np2\n)\n \n|\n \nselect\n(\nv\n.\np2\n,\n \ne\n.\np1\n)\n\n\n\n\n\n\nGraph(5 vertices, 20 edges, Symbol[:p2] vertex properties, Symbol[:p1] edge properties)\n\n\n\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Run an expression on each vertex\n\n\n@\nquery\n \ng\n \n|\n \neachvertex\n(\nv\n.\np1\n \n+\n \nv\n.\np2\n)\n\n\n\n\n\n\n10-element DataArrays.DataArray{Float64,1}:\n 0.906363\n 1.33634\n 1.00558\n 0.965068\n 0.857214\n 0.405383\n 0.637848\n 0.413947\n 0.727733\n 0.942215\n\n\n\n\n\nusing\n \nGraft\n\n\ng\n \n=\n \nrandgraph\n(\n10\n,\n \n[:\np1\n,\n \n:\np2\n],\n \n[:\np1\n,\n \n:\np2\n])\n\n\n\n# Run an expression on each edge\n\n\n@\nquery\n \ng\n \n|\n \nfilter\n(\ne\n.\np1\n \n \ne\n.\np2\n)\n \n|\n \neachedge\n(\ne\n.\np1\n \n+\n \ne\n.\np2\n)\n\n\n\n\n\n\n48-element DataArrays.DataArray{Float64,1}:\n 0.966906\n 1.47244\n 0.365215\n 1.30364\n 0.94188\n 0.732596\n 0.903553\n 1.24955\n 0.955426\n 0.882751\n \u22ee\n 0.589588\n 0.540468\n 1.22599\n 1.44737\n 0.965892\n 0.936342\n 1.20991\n 0.412197\n 0.346563\n\n\n\n\n\nThe entire query is parsed into a DAG, using a recursive descent parser, and then executed in a bottom up manner. The results of intermediate nodes, and fetched vertex properties are cached to avoid redundant computations.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#graft-documentation", 
            "text": "Graft Documentation  The Graph datastructure  EdgeIteration  Metadata  Queries", 
            "title": "Graft Documentation"
        }, 
        {
            "location": "/#the-graph-datastructure", 
            "text": "The Graph datatype is the core datastructure used in Graft.jl. The Graph datatype has the following fields: 1. nv     : The number of vertices in the graph. 2. ne     : The number of edges int he graph. 3. indxs  : The adjacency matrix for the graph. The SparseMatrixCSC type is used here, both             as an adjacency matrix and as an index table, that maps edges onto their entries in the             edge dataframe. 4. vdata  : A dataframe used to store vertex data. This dataframe is indexed by the internally used             vertex identifiers. 5. edata  : An edge dataframe used to store edge data. This dataframe is indexed by indxs datastructure. 6. lmap   : A label map that maps externally used labels onto the internally used vertex identifiers and vice versa.", 
            "title": "The Graph datastructure"
        }, 
        {
            "location": "/#accessors", 
            "text": "#  Graft.nv     Function .  The number of vertices in the adjacency matrix   source  The number of vertices in the graph   source  #  Graft.ne     Function .  The number of edges in the adjacency matrix   source  The number of edges in the graph   source  #  Graft.indxs     Function .  Retrieve the adjacency matrix / edge index table   source  #  Graft.vdata     Function .  Retrieve the vertex dataframe   source  #  Graft.edata     Function .  Retrieve the edge dataframe   source  #  Graft.lmap     Function .  Retrieve the label map   source", 
            "title": "Accessors"
        }, 
        {
            "location": "/#construction", 
            "text": "The following methods can be used to construct unlabelled graphs:  emptygraph\nrandgraph\ncompletegraph  Labelled graphs can be build using the constructors:  Graph(::Int, ::Vector)\nGraph(::Int, ::Vector, ::Int)", 
            "title": "Construction"
        }, 
        {
            "location": "/#combinatorial-stuff", 
            "text": "Basic methods on graph structure:  #  Graft.vertices     Function .  The list of the vertices in the graph   source  #  Graft.edges     Function .  Returns an edge iterator containing all edges in the graph   source  #  Graft.hasvertex     Function .  Check if the vertex(s) exists   source  #  Graft.hasedge     Function .  Check if the edge(s) exists   source  Adjacency queries:  #  Graft.fadj     Function .  Retrieve a list of vertices connected to vertex v.  This method spwans a new array, so is slow and malloc prone.  source  Vertex v's out-neighbors in the graph   source  #  Graft.fadj!     Function .  Retrieve a list of vertices connect to vertex v.  This method copies the adjacencies onto the input array, and is comparitively faster, and causes no mallocs.  source  Retrieve a list of vertices connect to vertex v.  This method copies the adjacencies onto the input array, and is comparitively faster, and causes no mallocs.  source  #  Graft.outdegree     Function .  Compute the outdegree of a vertex   source  Vertex v's outdegree in the graph   source  #  Graft.indegree     Function .  Compute the indegree of a vertex. This method is slow since reverse adjacencies are not stored  source  Vertex v's indegree in the graph   source", 
            "title": "Combinatorial stuff"
        }, 
        {
            "location": "/#graph-mutations", 
            "text": "Graphs can be modified using the following methods:  addvertex!(::Graph)\naddvertex!(::Graph, ::Any)\naddedge!(::Graph, ::Pair{Int,Int})\nrmvertex!(::Graph, ::Int)\nrmvertex!(::Graph, ::AbstractVector{Int})\nrmedge!(::Graph, ::Pair{Int,Int})", 
            "title": "Graph mutations"
        }, 
        {
            "location": "/#labelling", 
            "text": "New labels can be added or removed through the following methods:  #  Graft.setlabel!     Method .  Set labels for all vertices in the graph   source  #  Graft.setlabel!     Method .  Use a vertex property as the vertex label   source  #  Graft.setlabel!     Method .  Remove all vertex labels   source  Labels can be modified through the following methods:  #  Graft.relabel!     Method .  Relabel a single vertex in the graph   source  #  Graft.relabel!     Method .  Relabel a list of vertices in the graph   source", 
            "title": "Labelling"
        }, 
        {
            "location": "/#edgeiteration", 
            "text": "The EdgeIter type provides alloc-free and fast edge iteration.", 
            "title": "EdgeIteration"
        }, 
        {
            "location": "/#construction_1", 
            "text": "#  Graft.edges     Method .  Returns an edge iterator containing all edges in the graph   source", 
            "title": "Construction"
        }, 
        {
            "location": "/#getindex", 
            "text": "#  Base.getindex     Method .  Get the ith edge in the iterator   source  #  Base.getindex     Method .  Get a new iterator containing a subset of the edges   source  #  Base.getindex     Method .  Get a copy of the iterator   source", 
            "title": "Getindex"
        }, 
        {
            "location": "/#concatenation", 
            "text": "#  Base.vcat     Method .  Concatenate two iterators   source", 
            "title": "Concatenation"
        }, 
        {
            "location": "/#usage", 
            "text": "using   Graft  g   =   completegraph ( 3 )  # Construct Iterator  eit   =   edges ( g )  # Iterate through edges  for   e   in   eit \n    # Do something here  end  # In list comprehensions  [ e   for   e   in   eit ]   6-element Array{Pair{Int64,Int64},1}:\n 1= 2\n 1= 3\n 2= 1\n 2= 3\n 3= 1\n 3= 2", 
            "title": "Usage"
        }, 
        {
            "location": "/#metadata", 
            "text": "", 
            "title": "Metadata"
        }, 
        {
            "location": "/#setting-vertex-metadata", 
            "text": "#  Graft.setvprop!     Function .  Set vertex properties.  setvprop!(g::Graph, v::VertexID, val(s), vprop::Symbol) -  Set a property for v  source  setvprop!(g::Graph, vs::VertexList, val(s), vprop::Symbol) -  Set a property for v in vs   source  setvprop!(g::Graph, ::Colon, val(s), vprop::Symbol) -  Set a property for all vertices in g   source", 
            "title": "Setting vertex metadata"
        }, 
        {
            "location": "/#retrieving-vertex-metadata", 
            "text": "#  Graft.getvprop     Function .  Retrieve vertex properties.  getvprop(g::Graph, v::VertexID, vprop::Symbol) -  Fetch the value of a property for vertex v  source  getvprop(g::Graph, vs::VertexList, vprop::Symbol) -  Fetch the value of a property for v in vs   source  getvprop(g::Graph, ::Colon, vprop::Symbol) -  Fetch the value of a property for all verices   source", 
            "title": "Retrieving vertex metadata"
        }, 
        {
            "location": "/#setting-edge-metadata", 
            "text": "#  Graft.seteprop!     Function .  Set edge properties.  seteprop!(g::Graph, e::EdgeID, val, eprop::Symbol) -  Set a property for an edge e  source  seteprop!(g::Graph, es::EdgeList, val(s), eprop::Symbol) -  Set a property for e in es   source  seteprop!(g::Graph, ::Colon, val(s), eprop::Symbol)   source", 
            "title": "Setting edge metadata"
        }, 
        {
            "location": "/#retrieving-edge-metadata", 
            "text": "#  Graft.geteprop     Function .  Retrieve edge properties.  geteprop(g::Graph, e::EdgeID, eprop::Symbol) -  Fetch the value of a property for edge e  source  geteprop(g::Graph, es::EdgeList, eprop::Symbol) -  Fetch the value of a property for edge e in es   source  geteprop(g::Graph, ::Colon, eprop::Symbol) -  Fetch the value of a property for all edges   source", 
            "title": "Retrieving edge metadata"
        }, 
        {
            "location": "/#queries", 
            "text": "The query macro is used to execute graph queries in a pipelined manner. The pipelining syntax is borrowed from jplyer, though I hope to use jplyer directly at some point, for lazy execution.  The main functionalities provided by the query macro are:", 
            "title": "Queries"
        }, 
        {
            "location": "/#eachvertex", 
            "text": "This abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.  For example,  @query g |  eachvertex(v.p1 + v.p2 * v.p3)  executes the expression  v.p1 + v.p2 * v.p3  on every vertex in the result from the previous pipeline stage. Here,  v.p1  denotes the value of property  p1  for every vertex.", 
            "title": "eachvertex:"
        }, 
        {
            "location": "/#eachedge", 
            "text": "This abstraction is used to run an expression on every vertex in the graph, and retrieve a vector result.  For example,  @query g |  eachedge(e.p1 + s.p1 + t.p1)  executes the expression  e.p1 + s.p1 + t.p1  on every edge in the graph. Here, 'e.p1' denotes the value of property  p1  for every edge in the graph. Since each edge has a source vertex  s  and a target vertex  t , the properties of these vertices can be used in the expression as shown by  s.p1  and  t.p1 .", 
            "title": "eachedge:"
        }, 
        {
            "location": "/#filter", 
            "text": "This abstraction is used to compute a subgraph of the input from the previous pipeline stage, on the given conditions.  For example,  @query g |  filter(v.p1   5, v.p1   v.p2, e.p1   5)  uses the three filter conditions provided to compute a subgraph. Currently only binary comparisons are supported, so comparisons like 1   v.p1   v.p2 will not work. Instead you can supply multiple conditions as separate arguments.", 
            "title": "filter"
        }, 
        {
            "location": "/#select", 
            "text": "This abstraction is used to compute a subgraph of the input from the previous pipeline state, for a subset of vertex and or edge properties.  For example,  @query g |  select(v.p1, v.p3, e.p1)  preserves only vertex properties  p1 , p2  and edge property  p1 .", 
            "title": "select"
        }, 
        {
            "location": "/#examples", 
            "text": "The abstractions can be chained together using the pipe notation, so that the output of one stage becomes the input to the next.  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Run a filter using vertex properties  @ query   g   |   filter ( 0.5   =   v . p1 ,   v . p1     v . p2 )   Graph(1 vertices, 0 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Run a filter using source and target properties  @ query   g   |   filter ( s . p1     t . p2 )   Graph(10 vertices, 61 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Run filter using edge properties  @ query   g   |   filter ( e . p1     0.7 )   Graph(10 vertices, 57 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Chain filter expressions  @ query   g   |   filter ( v . p1     v . p2 )   |   filter ( e . p1     e . p1 )   Graph(5 vertices, 0 edges, Symbol[:p1,:p2] vertex properties, Symbol[:p1,:p2] edge properties)  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Select properties  @ query   g   |   filter ( v . p1     v . p2 )   |   select ( v . p2 ,   e . p1 )   Graph(5 vertices, 20 edges, Symbol[:p2] vertex properties, Symbol[:p1] edge properties)  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Run an expression on each vertex  @ query   g   |   eachvertex ( v . p1   +   v . p2 )   10-element DataArrays.DataArray{Float64,1}:\n 0.906363\n 1.33634\n 1.00558\n 0.965068\n 0.857214\n 0.405383\n 0.637848\n 0.413947\n 0.727733\n 0.942215  using   Graft  g   =   randgraph ( 10 ,   [: p1 ,   : p2 ],   [: p1 ,   : p2 ])  # Run an expression on each edge  @ query   g   |   filter ( e . p1     e . p2 )   |   eachedge ( e . p1   +   e . p2 )   48-element DataArrays.DataArray{Float64,1}:\n 0.966906\n 1.47244\n 0.365215\n 1.30364\n 0.94188\n 0.732596\n 0.903553\n 1.24955\n 0.955426\n 0.882751\n \u22ee\n 0.589588\n 0.540468\n 1.22599\n 1.44737\n 0.965892\n 0.936342\n 1.20991\n 0.412197\n 0.346563  The entire query is parsed into a DAG, using a recursive descent parser, and then executed in a bottom up manner. The results of intermediate nodes, and fetched vertex properties are cached to avoid redundant computations.", 
            "title": "Examples"
        }
    ]
}